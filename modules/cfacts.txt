[INTRODUCTION. Introduction] A bibliography lists documents that were referred to during the preparation of the standard.
[3.4.1 Terms, definitions, and symbols] An example of implementation-defined behavior is the propagation of the high-order bit when a signed integer is shifted right.
[3.4.2 Terms, definitions, and symbols] An example of locale-specific behavior is whether the islower function returns true for characters other than the 26 lowercase Latin letters.
[3.4.3 Terms, definitions, and symbols] An example of undefined behavior is the behavior on integer overflow.
[3.4.4 Terms, definitions, and symbols] Unspecified behavior is the use of an unspecified value, or other behavior where this International Standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance.
[3.4.4 Terms, definitions, and symbols] An example of unspecified behavior is the order in which the arguments to a function are evaluated.
[3.6 Terms, definitions, and symbols] A byte is composed of a contiguous sequence of bits, the number of which is implementation-defined.
[3.6 Terms, definitions, and symbols] The least significant bit is called the low-order bit.
[3.6 Terms, definitions, and symbols] The most significant bit is called the high-order bit.
[3.15 Terms, definitions, and symbols] An object is a region of data storage in the execution environment, the contents of which can represent values.
[3.15 Terms, definitions, and symbols] When referenced, an object may be interpreted as having a particular type.
[4. Conformance] In this International Standard, ``shall'' is to be interpreted as a requirement on an implementation or on a program; conversely, ``shall not'' is to be interpreted as a prohibition.
[4. Conformance] If a ``shall'' or ``shall not'' requirement that appears outside of a constraint or runtime-constraint is violated, the behavior is undefined.
[4. Conformance] A program that is correct in all other aspects, operating on correct data, containing unspecified behavior shall be a correct program.
[4. Conformance] The implementation shall not successfully translate a preprocessing translation unit containing a #error preprocessing directive unless it is part of a group skipped by conditional inclusion.
[4. Conformance] A strictly conforming program shall use only those features of the language and library specified in this International Standard. It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.
[4. Conformance] The two forms of conforming implementation are hosted and freestanding.
[4. Conformance] A conforming hosted implementation shall accept any strictly conforming program.
[4. Conformance] A conforming freestanding implementation shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers <float.h>, <iso646.h>, <limits.h>, <stdalign.h>, <stdarg.h>, <stdbool.h>, <stddef.h>, <stdint.h>, and <stdnoreturn.h>.
[4. Conformance] A conforming program is one that is acceptable to a conforming implementation.
[4. Conformance] A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any strictly conforming program.
[4. Conformance] An implementation shall be accompanied by a document that defines all implementation-defined and locale-specific characteristics and all extensions.
[5. Environment] An implementation translates C source files and executes C programs in two data-processing-system environments, which will be called the translation environment and the execution environment.
[5.1.1.1 Program structure] A source file together with all the headers and source files included via the preprocessing directive #include is known as a preprocessing translation unit.
[5.1.1.1 Program structure] After preprocessing, a preprocessing translation unit is called a translation unit.
[5.1.1.2 Translation phases] A source file that is not empty shall end in a new-line character.
[5.1.1.2 Translation phases] A source file shall not end in a partial preprocessing token or in a partial comment.
[5.1.1.2 Translation phases] If a character sequence that matches the syntax of a universal character name is produced by token concatenation, the behavior is undefined.
[5.1.1.2 Translation phases] Source files, translation units, and translated translation units need not necessarily be stored as files.
[5.1.1.3 Diagnostics] A conforming implementation shall produce at least one diagnostic message (identified in an implementation-defined manner) if a preprocessing translation unit or translation unit contains a violation of any syntax rule or constraint, even if the behavior is also explicitly specified as undefined or implementation-defined.
[5.1.1.3 Diagnostics] An implementation shall issue a diagnostic for the translation unit: char i; int i; because in those cases where wording in this International Standard describes the behavior for a construct as being both a constraint error and resulting in undefined behavior, the constraint error shall be diagnosed.
[5.1.2 Execution environments] Two execution environments are defined: freestanding and hosted. In both cases, program startup occurs when a designated C function is called by the execution environment.
[5.1.2 Execution environments] All objects with static storage duration shall be initialized (set to their initial values) before program startup.
[5.1.2.2.1 Program startup] In a hosted environment, the function called at program startup is named main.
[5.1.2.2.1 Program startup] The main function shall be defined with a return type of int and no parameters, or with two parameters int argc and char *argv[] (though any names may be used) or equivalent, or in some other implementation-defined manner.
[5.1.2.2.1 Program startup] If they are declared, the parameters to the main function shall obey the following constraints: The value of argc shall be nonnegative; argv[argc] shall be a null pointer.
[5.1.2.2.1 Program startup] If the value of argc is greater than zero, the array members argv[0] through argv[argc-1] inclusive shall contain pointers to strings, which are given implementation-defined values by the host environment prior to program startup.
[5.1.2.2.1 Program startup] If the host environment is not capable of supplying strings with letters in both uppercase and lowercase, the implementation shall ensure that the strings are received in lowercase.
[5.1.2.2.1 Program startup] If the value of argc is greater than zero, the string pointed to by argv[0] represents the program name; argv[0][0] shall be the null character if the program name is not available from the host environment.
[5.1.2.2.1 Program startup] If the value of argc is greater than one, the strings pointed to by argv[1] through argv[argc-1] represent the program parameters.
[5.1.2.2.1 Program startup] The parameters argc and argv and the strings pointed to by the argv array shall be modifiable by the program, and retain their last-stored values between program startup and program termination.
[5.1.2.2.3 Program termination] If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument; reaching the } that terminates the main function returns a value of 0.
[5.1.2.2.3 Program termination] If the return type is not compatible with int, the termination status returned to the host environment is unspecified.
[5.1.2.3 Program execution] The semantic descriptions in this International Standard describe the behavior of an abstract machine in which issues of optimization are irrelevant.
[5.1.2.3 Program execution] Given any two evaluations A and B, if A is sequenced before B, then the execution of A shall precede the execution of B.
[5.1.2.3 Program execution] Given any two evaluations A and B, if A is not sequenced before or after B, then A and B are unsequenced.
[5.1.2.3 Program execution] Given any two evaluations A and B, A and B are indeterminately sequenced when A is sequenced either before or after B, but it is unspecified which. The presence of a sequence point between the evaluation of expressions A and B implies that every value computation and side effect associated with A is sequenced before every value computation and side effect associated with B.
[5.1.2.3 Program execution] An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or accessing a volatile object).
[5.1.2.3 Program execution] When the processing of the abstract machine is interrupted by receipt of a signal, the values of objects that are neither lock-free atomic objects nor of type volatile sig_atomic_t are unspecified, as is the state of the floating-point environment.
[5.1.2.3 Program execution] At program termination, all data written into files shall be identical to the result that execution of the program according to the abstract semantics would have produced.
[5.1.2.4 Multi-threaded executions and data races] A synchronization operation on one or more memory locations is either an acquire operation, a release operation, both an acquire and release operation, or a consume operation.
[5.1.2.4 Multi-threaded executions and data races] A synchronization operation without an associated memory location is a fence and can be either an acquire fence, a release fence, or both an acquire and release fence.
[5.1.2.4 Multi-threaded executions and data races] Performing a release operation on a mutex forces prior side effects on other memory locations to become visible to other threads that later perform an acquire or consume operation on the mutex.
[5.1.2.4 Multi-threaded executions and data races] If A and B are modifications of an atomic object M, and A happens before B, then A shall precede B in the modification order of M.
[5.1.2.4 Multi-threaded executions and data races] A release sequence headed by a release operation A on an atomic object M is a maximal contiguous sub-sequence of side effects in the modification order of M, where the first operation is A and every subsequent operation either is performed by the same thread that performed the release or is an atomic read-modify-write operation.
[5.1.2.4 Multi-threaded executions and data races] An evaluation A is dependency-ordered before an evaluation B if: A performs a release operation on an atomic object M, and, in another thread, B performs a consume operation on M and reads a value written by any side effect in the release sequence headed by A, or for some evaluation X, A is dependency-ordered before X and X carries a dependency to B.
[5.1.2.4 Multi-threaded executions and data races] An evaluation A inter-thread happens before an evaluation B if A synchronizes with B, A is dependency-ordered before B, or, for some evaluation X: -- A synchronizes with X and X is sequenced before B, -- A is sequenced before X and X inter-thread happens before B, or -- A inter-thread happens before X and X inter-thread happens before B.
[5.1.2.4 Multi-threaded executions and data races] An evaluation A happens before an evaluation B if A is sequenced before B or A inter-thread happens before B.
[5.1.2.4 Multi-threaded executions and data races] A visible side effect A on an object M with respect to a value computation B of M satisfies the conditions: -- A happens before B, and --there is no other side effect X to M such that A happens before X and X happens before B.
[5.1.2.4 Multi-threaded executions and data races] If there is ambiguity about which side effect to a non-atomic object is visible, then there is a data race and the behavior is undefined.
[5.1.2.4 Multi-threaded executions and data races] The value of an atomic object M, as determined by evaluation B, shall be the value stored by some operation in the visible sequence of M with respect to B.
[5.1.2.4 Multi-threaded executions and data races] If a value computation A of an atomic object M happens before a value computation B of M, and the value computed by A corresponds to the value stored by side effect X, then the value computed by B shall either equal the value computed by A, or be the value stored by side effect Y, where Y follows X in the modification order of M.
[5.1.2.4 Multi-threaded executions and data races] The execution of a program contains a data race if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.
[5.2.1 Character sets] Two sets of characters and their associated collating sequences shall be defined: the set in which source files are written (the source character set ), and the set interpreted in the execution environment (the execution character set ).
[5.2.1 Character sets] In a character constant or string literal, members of the execution character set shall be represented by corresponding members of the source character set or by escape sequences consisting of the backslash \ followed by one or more characters.
[5.2.1 Character sets] A byte with all bits set to 0, called the null character, shall exist in the basic execution character set; it is used to terminate a character string.
[5.2.1 Character sets] Both the basic source and basic execution character sets shall have the following members: the 26 uppercase letters of the Latin alphabet, the 26 lowercase letters of the Latin alphabet, the 10 decimal digits, and the following 29 graphic characters ! " # % & ' ( ) * +, -.
[5.2.1 Character sets] The representation of each member of the source and execution basic character sets shall fit in a byte.
[5.2.1 Character sets] In both the source and execution basic character sets, the value of each character after 0 in the list of decimal digits shall be one greater than the value of the previous.
[5.2.1 Character sets] In source files, there shall be some way of indicating the end of each line of text; this International Standard treats such an end-of-line indicator as if it were a single new-line character.
[5.2.1 Character sets] In the basic execution character set, there shall be control characters representing alert, backspace, carriage return, and new line.
[5.2.1 Character sets] If any characters other than those specified for the basic source and basic execution character sets are encountered in a source file (except in an identifier, a character constant, a string literal, a header name, a comment, or a preprocessing token that is never converted to a token), the behavior is undefined.
[5.2.1 Character sets] A letter is an uppercase letter or a lowercase letter as defined in the Latin alphabet; in this International Standard the term does not include other characters that are letters in other alphabets.
[5.2.1.1 Trigraph sequences] The trigraph sequences enable the input of characters that are not defined in the Invariant Code Set as described in ISO/IEC 646, which is a subset of the seven-bit US ASCII code set.
[5.2.1.1 Trigraph sequences] The following tokens, ??= ??) ??! ??( ??' ??> ??/ ??< and ??-, are known as trigraph sequences.
[5.2.1.2 Multibyte characters] The source character set and the execution character set may both contain multibyte characters. If so, the basic character set shall be present and each character shall be encoded as a single byte.
[5.2.1.2 Multibyte characters] A byte with all bits zero shall be interpreted as a null character.
[5.2.1.2 Multibyte characters] A null character shall not occur as part of any other multibyte character.
[5.2.1.2 Multibyte characters] An identifier, comment, string literal, character constant, or header name shall consist of a sequence of valid multibyte characters.
[5.2.2 Character display semantics] The active position is that location on a display device where the next character output by the fputc function would appear.
[5.2.2 Character display semantics] The direction of writing characters to the display device is locale-specific.
[5.2.2 Character display semantics] If the active position is at the final position of a line (if there is one), the behavior of the display device is unspecified.
[5.2.2 Character display semantics] Alphabetic escape sequences representing nongraphic characters in the execution character set are intended to produce actions on display devices. The \a (alert) escape sequence produces an audible or visible alert without changing the active position.
[5.2.2 Character display semantics] Alphabetic escape sequences representing nongraphic characters in the execution character set are intended to produce actions on display devices. The \b (backspace) escape sequence moves the active position to the previous position on the current line.
[5.2.2 Character display semantics] Alphabetic escape sequences representing nongraphic characters in the execution character set are intended to produce actions on display devices. The \f (form feed) escape sequence moves the active position to the initial position at the start of the next logical page.
[5.2.2 Character display semantics] Alphabetic escape sequences representing nongraphic characters in the execution character set are intended to produce actions on display devices. The \n (new line) escape sequence moves the active position to the initial position of the next line.
[5.2.2 Character display semantics] Alphabetic escape sequences representing nongraphic characters in the execution character set are intended to produce actions on display devices. The \r (carriage return) escape sequence moves the active position to the initial position of the current line.
[5.2.2 Character display semantics] Alphabetic escape sequences representing nongraphic characters in the execution character set are intended to produce actions on display devices. The \t (horizontal tab) escape sequence moves the active position to the next horizontal tabulation position on the current line.
[5.2.2 Character display semantics] Alphabetic escape sequences representing nongraphic characters in the execution character set are intended to produce actions on display devices. The \v (vertical tab) escape sequence moves the active position to the initial position of the next vertical tabulation position.
[5.2.2 Character display semantics] Alphabetic escape sequences representing nongraphic characters in the execution character set are intended to produce actions on display devices. Each of these escape sequences shall produce a unique implementation-defined value which can be stored in a single char object.
[5.2.3 Signals and interrupts] Functions shall be implemented such that they may be interrupted at any time by a signal, or may be called by a signal handler, or both, with no alteration to earlier, but still active, invocations' control flow (after the interruption), function return values, or objects with automatic storage duration.
[5.2.3 Signals and interrupts] When a function is interrupted by a signal, or called by a signal handler, all objects with automatic storage duration shall be maintained outside the function image (the instructions that compose the executable representation of a function) on a per-invocation basis.
[5.2.3 Signals and interrupts] A function image is the instructions that compose the executable representation of a function.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 127 nesting levels of blocks.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 63 nesting levels of conditional inclusion.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 12 pointer, array, and function declarators (in any combinations) modifying an arithmetic, structure, union, or void type in a declaration.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 63 nesting levels of parenthesized declarators within a full declaration.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 63 nesting levels of parenthesized expressions within a full expression.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 63 significant initial characters in an internal identifier or a macro name (each universal character name or extended source character is considered a single character).
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 4095 external identifiers in one translation unit.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 511 identifiers with block scope declared in one block.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 4095 macro identifiers simultaneously defined in one preprocessing translation unit.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 127 parameters in one function definition.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 127 arguments in one function call.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 127 parameters in one macro definition.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 127 arguments in one macro invocation.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 4095 characters in a logical source line.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 4095 characters in a string literal (after concatenation).
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 65535 bytes in an object (in a hosted environment only).
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 15 nesting levels for #included files.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 1023 case labels for a switch statement (excluding those for any nested switch statements).
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 1023 members in a single structure or union.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 1023 enumeration constants in a single enumeration.
[5.2.4.1 Translation limits] The implementation shall be able to translate and execute at least one program that contains the following limit: 63 levels of nested structure or union definitions in a single struct-declaration-list..
[5.2.4.2 Numerical limits] An implementation is required to document all the numerical limits specified in the headers <limits.h> and <float.h>.
[5.2.4.2.1 Sizes of integer types <limits.h>] CHAR_BIT is the number of bits for smallest object that is not a bit-field (byte).
[5.2.4.2.1 Sizes of integer types <limits.h>] SCHAR_MIN is the minimum value for an object of type signed char.
[5.2.4.2.1 Sizes of integer types <limits.h>] SCHAR_MAX is the maximum value for an object of type signed char.
[5.2.4.2.1 Sizes of integer types <limits.h>] UCHAR_MAX is the maximum value for an object of type unsigned char.
[5.2.4.2.1 Sizes of integer types <limits.h>] CHAR_MIN is the minimum value for an object of type char.
[5.2.4.2.1 Sizes of integer types <limits.h>] CHAR_MAX is the maximum value for an object of type char.
[5.2.4.2.1 Sizes of integer types <limits.h>] MB_LEN_MAX is the maximum number of bytes in a multibyte character, for any supported locale.
[5.2.4.2.1 Sizes of integer types <limits.h>] SHRT_MIN is the minimum value for an object of type short int.
[5.2.4.2.1 Sizes of integer types <limits.h>] SHRT_MAX is the maximum value for an object of type short int.
[5.2.4.2.1 Sizes of integer types <limits.h>] USHRT_MAX is the maximum value for an object of type unsigned short int.
[5.2.4.2.1 Sizes of integer types <limits.h>] INT_MIN is the minimum value for an object of type int.
[5.2.4.2.1 Sizes of integer types <limits.h>] INT_MAX is the maximum value for an object of type int.
[5.2.4.2.1 Sizes of integer types <limits.h>] UINT_MAX is the maximum value for an object of type unsigned int.
[5.2.4.2.1 Sizes of integer types <limits.h>] LONG_MIN is the minimum value for an object of type long int.
[5.2.4.2.1 Sizes of integer types <limits.h>] LONG_MAX is the maximum value for an object of type long int.
[5.2.4.2.1 Sizes of integer types <limits.h>] ULONG_MAX is the maximum value for an object of type unsigned long int.
[5.2.4.2.1 Sizes of integer types <limits.h>] LLONG_MIN is the minimum value for an object of type long long int.
[5.2.4.2.1 Sizes of integer types <limits.h>] LLONG_MAX is the maximum value for an object of type long long int.
[5.2.4.2.1 Sizes of integer types <limits.h>] ULLONG_MAX is the maximum value for an object of type unsigned long long int.
[5.2.4.2.1 Sizes of integer types <limits.h>] If the value of an object of type char is treated as a signed integer when used in an expression, the value of CHAR_MIN shall be the same as that of SCHAR_MIN and the value of CHAR_MAX shall be the same as that of SCHAR_MAX.
[5.2.4.2.1 Sizes of integer types <limits.h>] If the value of an object of type char is treated as an unsigned integer when used in an expression, the value of CHAR_MIN shall be 0 and the value of CHAR_MAX shall be the same as that of UCHAR_MAX.
[5.2.4.2.2 Characteristics of floating types <float.h>] A NaN is an encoding signifying Not-a-Number.
[5.2.4.2.2 Characteristics of floating types <float.h>] A quiet NaN propagates through almost every arithmetic operation without raising a floating-point exception; a signaling NaN generally raises a floating-point exception when occurring as an arithmetic operand.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, an implementation may give zero and values that are not floating-point numbers (such as infinities and NaNs) a sign or may leave them unsigned.
[5.2.4.2.2 Characteristics of floating types <float.h>] Wherever floating-point values such as 0, infinity or NaN are unsigned, any requirement in this International Standard to retrieve the sign shall produce an unspecified sign, and any requirement to set the sign shall be ignored.
[5.2.4.2.2 Characteristics of floating types <float.h>] The rounding mode for floating-point addition is characterized by the implementation-defined value of FLT_ROUNDS; a value of -1 signifies indeterminable rounding.
[5.2.4.2.2 Characteristics of floating types <float.h>] The rounding mode for floating-point addition is characterized by the implementation-defined value of FLT_ROUNDS; a value of 0 signifies rounding toward zero.
[5.2.4.2.2 Characteristics of floating types <float.h>] The rounding mode for floating-point addition is characterized by the implementation-defined value of FLT_ROUNDS; a value of 1 signifies rounding to nearest.
[5.2.4.2.2 Characteristics of floating types <float.h>] The rounding mode for floating-point addition is characterized by the implementation-defined value of FLT_ROUNDS; a value of 2 signifies rounding toward positive infinity.
[5.2.4.2.2 Characteristics of floating types <float.h>] The rounding mode for floating-point addition is characterized by the implementation-defined value of FLT_ROUNDS; a value of 3 signifies rounding toward negative infinity.
[5.2.4.2.2 Characteristics of floating types <float.h>] Except for assignment and cast, the values yielded by operators with floating operands are evaluated in a format characterized by the implementation-defined value of FLT_EVAL_METHOD; a value of -1 signifies indeterminable evaluation format.
[5.2.4.2.2 Characteristics of floating types <float.h>] Except for assignment and cast, the values yielded by operators with floating operands are evaluated in a format characterized by the implementation-defined value of FLT_EVAL_METHOD; a value of 0 signifies all operations and constants are evaluated just to the range and precision of the type.
[5.2.4.2.2 Characteristics of floating types <float.h>] Except for assignment and cast, the values yielded by operators with floating operands are evaluated in a format characterized by the implementation-defined value of FLT_EVAL_METHOD; a value of 1 signifies operations and constants of type float and double are evaluated to the range and precision of the double type.
[5.2.4.2.2 Characteristics of floating types <float.h>] Except for assignment and cast, the values yielded by operators with floating operands are evaluated in a format characterized by the implementation-defined value of FLT_EVAL_METHOD; a value of 2 signifies all operations and constants are evaluated to the range and precision of the long double type.
[5.2.4.2.2 Characteristics of floating types <float.h>] The presence or absence of floating-point subnormal numbers is characterized by the implementation-defined values of FLT_HAS_SUBNORM, DBL_HAS_SUBNORM, and LDBL_HAS_SUBNORM; a value of -1 signifies that it is indeterminable whether subnormal numbers are present.
[5.2.4.2.2 Characteristics of floating types <float.h>] The presence or absence of floating-point subnormal numbers is characterized by the implementation-defined values of FLT_HAS_SUBNORM, DBL_HAS_SUBNORM, and LDBL_HAS_SUBNORM; a value of 0 signifies that subnormal numbers are absent (type does not support subnormal numbers).
[5.2.4.2.2 Characteristics of floating types <float.h>] The presence or absence of floating-point subnormal numbers is characterized by the implementation-defined values of FLT_HAS_SUBNORM, DBL_HAS_SUBNORM, and LDBL_HAS_SUBNORM; a value of 1 signifies that subnormal numbers are present (type does support subnormal numbers).
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_RADIX is the minimum value for the radix of exponent representation.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_MANT_DIG is the number of base-FLT_RADIX digits in the floating-point significand.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_MANT_DIG is the number of base-FLT_RADIX digits in the double-precision floating-point significand.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_MANT_DIG is the number of base-FLT_RADIX digits in the long double-precision floating-point significand.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_DECIMAL_DIG is the number of decimal digits, n, such that any floating-point number with p radix b digits can be rounded to a floating-point number with n decimal digits and back again without change to the value.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_DECIMAL_DIG is the number of decimal digits, n, such that any double-precision floating-point number with p radix b digits can be rounded to a floating-point number with n decimal digits and back again without change to the value.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_DECIMAL_DIG is the number of decimal digits, n, such that any long double-precision floating-point number with p radix b digits can be rounded to a floating-point number with n decimal digits and back again without change to the value.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DECIMAL_DIG is the number of decimal digits, n, such that any floating-point number in the widest supported floating type with pmax radix b digits can be rounded to a floating-point number with n decimal digits and back again without change to the value.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_DIG is the number of decimal digits, q, such that any floating-point number with q decimal digits can be rounded into a floating-point number with p radix b digits and back again without change to the q decimal digits.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_DIG is the number of decimal digits, q, such that any double-precision floating-point number with q decimal digits can be rounded into a floating-point number with p radix b digits and back again without change to the q decimal digits.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_DIG is the number number of decimal digits, q, such that any long double-precision floating-point number with q decimal digits can be rounded into a floating-point number with p radix b digits and back again without change to the q decimal digits.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_MIN_EXP is the minimum negative integer such that FLT_RADIX raised to one less than that power is a normalized floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_MIN_EXP is the minimum negative integer such that FLT_RADIX raised to one less than that power is a normalized double-precision floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_MIN_EXP is the minimum negative integer such that FLT_RADIX raised to one less than that power is a normalized long double-precision floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_MIN_10_EXP is the minimum negative integer such that 10 raised to that power is in the range of normalized floating-point numbers.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_MIN_10_EXP is the minimum negative integer such that 10 raised to that power is in the range of normalized double-precision floating-point numbers.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_MIN_10_EXP is the minimum negative integer such that 10 raised to that power is in the range of normalized long double-precision floating-point numbers.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_MAX_EXP is the maximum integer such that FLT_RADIX raised to one less than that power is a representable finite floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_MAX_EXP is the maximum integer such that FLT_RADIX raised to one less than that power is a representable finite double-precision floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_MAX_EXP is the maximum integer such that FLT_RADIX raised to one less than that power is a representable finite long double-precision floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_MAX_10_EXP is the maximum integer such that 10 raised to that power is in the range of representable finite floating-point numbers.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_MAX_10_EXP is the maximum integer such that 10 raised to that power is in the range of representable finite double-precision floating-point numbers.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_MAX_10_EXP is the maximum integer such that 10 raised to that power is in the range of representable finite long double-precision floating-point numbers.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_MAX is the maximum representable finite floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_MAX is the maximum representable finite double-precision floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_MAX is the maximum representable finite long double-precision floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_EPSILON is the difference between 1 and the least value greater than 1 that is representable in the given floating point type.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_EPSILON is the difference between 1 and the least value greater than 1 that is representable in the given double-precision floating point type.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_EPSILON is the difference between 1 and the least value greater than 1 that is representable in the given long double-precision floating point type.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_MIN is the minimum normalized positive floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_MIN is the minimum normalized positive double-precision floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_MIN is the minimum normalized positive long double-precision floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, FLT_TRUE_MIN is the minimum positive floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, DBL_TRUE_MIN is the minimum positive double-precision floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] Regarding floating types, LDBL_TRUE_MIN is the minimum positive long double-precision floating-point number.
[5.2.4.2.2 Characteristics of floating types <float.h>] If the presence or absence of subnormal numbers is indeterminable, then the value is intended to be a positive number no greater than the minimum normalized positive number for the type.
[5.2.4.2.2 Characteristics of floating types <float.h>] If a type wider than double were supported, then DECIMAL_DIG would be greater than 17.
[6.1 Notation] An optional symbol is indicated by the subscript ``opt'', so that { expressionopt } indicates an optional expression enclosed in braces.
[6.1 Notation] When syntactic categories are referred to in the main text, they are not italicized and words are separated by spaces instead of hyphens.
[6.2.1 Scopes of identifiers] A member of an enumeration is called an enumeration constant.
[6.2.1 Scopes of identifiers] A label name is the only kind of identifier that has function scope.
[6.2.1 Scopes of identifiers] If the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has file scope, which terminates at the end of the translation unit.
[6.2.1 Scopes of identifiers] If the declarator or type specifier that declares the identifier appears inside a block or within the list of parameter declarations in a function definition, the identifier has block scope, which terminates at the end of the associated block.
[6.2.1 Scopes of identifiers] If the declarator or type specifier that declares the identifier appears within the list of parameter declarations in a function prototype (not part of a function definition), the identifier has function prototype scope, which terminates at the end of the function declarator.
[6.2.1 Scopes of identifiers] If an identifier designates two different entities in the same name space, the scopes might overlap.
[6.2.1 Scopes of identifiers] If the scopes of two different entities in the same name space overlap, the scope of one entity (the inner scope) will end strictly before the scope of the other entity (the outer scope).
[6.2.2 Linkages of identifiers] If the declaration of a file scope identifier for an object or a function contains the storage-class specifier static, the identifier has internal linkage.
[6.2.2 Linkages of identifiers] A function declaration can contain the storage-class specifier static only if it is at file scope.
[6.2.2 Linkages of identifiers] If no prior declaration is visible, or if the prior declaration specifies no linkage, then the identifier has external linkage.
[6.2.2 Linkages of identifiers] If the declaration of an identifier for a function has no storage-class specifier, its linkage is determined exactly as if it were declared with the storage-class specifier extern.
[6.2.2 Linkages of identifiers] If the declaration of an identifier for an object has file scope and no storage-class specifier, its linkage is external.
[6.2.2 Linkages of identifiers] If, within a translation unit, the same identifier appears with both internal and external linkage, the behavior is undefined.
[6.2.3 Name spaces of identifiers] If more than one declaration of a particular identifier is visible at any point in a translation unit, the syntactic context disambiguates uses that refer to different entities.
[6.2.4 Storage durations of objects] An object exists, has a constant address, and retains its last-stored value throughout its lifetime. If an object is referred to outside of its lifetime, the behavior is undefined.
[6.2.4 Storage durations of objects] An object whose identifier is declared without the storage-class specifier _Thread_local, and either with external or internal linkage or with the storage-class specifier static, has static storage duration.
[6.2.4 Storage durations of objects] An object whose identifier is declared with the storage-class specifier _Thread_local has thread storage duration.
[6.2.4 Storage durations of objects] An object whose identifier is declared with no linkage and without the storage-class specifier static has automatic storage duration.
[6.2.4 Storage durations of objects] The result of attempting to indirectly access an object with automatic storage duration from a thread other than the one with which the object is associated is implementation-defined.
[6.2.4 Storage durations of objects] For an object with automatic storage duration, if a block is entered recursively, a new instance of the object is created each time.
[6.2.4 Storage durations of objects] The initial value of an object with automatic storage duration is indeterminate.
[6.2.4 Storage durations of objects] If an initialization is specified for an object with automatic storage duration, it is performed each time the declaration or compound literal is reached in the execution of a block; otherwise, the value becomes indeterminate each time the declaration is reached.
[6.2.5 Types] An object declared as type _Bool is just large enough to store the values 0 and 1.
[6.2.5 Types] An object declared as type char is just large enough to store any member of the basic execution character set.
[6.2.5 Types] If a member of the basic execution character set is stored in a char object, its value is guaranteed to be nonnegative.
[6.2.5 Types] There are five standard signed integer types, designated as signed char, short int, int, long int, and long long int.
[6.2.5 Types] A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type.
[6.2.5 Types] The standard and extended signed integer types are collectively called signed integer types.
[6.2.5 Types] The standard and extended unsigned integer types are collectively called unsigned integer types.
[6.2.5 Types] The standard signed integer types and standard unsigned integer types are collectively called the standard integer types.
[6.2.5 Types] The extended signed integer types and extended unsigned integer types are collectively called the extended integer types.
[6.2.5 Types] For any two integer types with the same signedness and different integer conversion rank the range of values of the type with smaller integer conversion rank is a subrange of the values of the other type.
[6.2.5 Types] There are three complex types, designated as float _Complex, double _Complex, and long double _Complex.
[6.2.5 Types] The real floating and complex types are collectively called the floating types.
[6.2.5 Types] The type char, the signed and unsigned integer types, and the floating types are collectively called the basic types.
[6.2.5 Types] The three types char, signed char, and unsigned char are collectively called the character types.
[6.2.5 Types] An implementation may define new keywords that provide alternative ways to designate a basic (or any other) type; this does not violate the requirement that all basic types be different.
[6.2.5 Types] The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char.
[6.2.5 Types] An enumeration comprises a set of named integer constant values.
[6.2.5 Types] An array type describes a contiguously allocated nonempty set of objects with a particular member object type, called the element type.
[6.2.5 Types] The element type shall be complete whenever the array type is specified.
[6.2.5 Types] An array type is said to be derived from its element type, and if its element type is T, the array type is sometimes called ``array of T''.
[6.2.5 Types] The construction of an array type from an element type is called ``array type derivation''.
[6.2.5 Types] A structure type describes a sequentially allocated nonempty set of member objects (and, in certain circumstances, an incomplete array), each of which has an optionally specified name and possibly distinct type.
[6.2.5 Types] A union type describes an overlapping nonempty set of member objects, each of which has an optionally specified name and possibly distinct type.
[6.2.5 Types] A function type describes a function with specified return type.
[6.2.5 Types] A function type is characterized by its return type and the number and types of its parameters.
[6.2.5 Types] A function type is said to be derived from its return type, and if its return type is T, the function type is sometimes called ``function returning T''.
[6.2.5 Types] The construction of a function type from a return type is called ``function type derivation''.
[6.2.5 Types] A pointer type describes an object whose value provides a reference to an entity of the referenced type.
[6.2.5 Types] A pointer type derived from the referenced type T is sometimes called ``pointer to T''.
[6.2.5 Types] The construction of a pointer type from a referenced type is called ``pointer type derivation''.
[6.2.5 Types] An atomic type describes the type designated by the construct _Atomic ( type-name ).
[6.2.5 Types] An array type of unknown size is an incomplete type.
[6.2.5 Types] A type has known constant size if the type is not incomplete and is not a variable length array type.
[6.2.5 Types] A declarator type derivation from a type T is the construction of a derived declarator type from T by the application of an array-type, a function-type, or a pointer-type derivation to T.
[6.2.5 Types] A derived type is not qualified by the qualifiers (if any) of the type from which it is derived.
[6.2.5 Types] A pointer to void shall have the same representation and alignment requirements as a pointer to a character type. Similarly, pointers to qualified or unqualified versions of compatible types shall have the same representation and alignment requirements.
[6.2.5 Types] All pointers to structure types shall have the same representation and alignment requirements as each other.
[6.2.5 Types] All pointers to union types shall have the same representation and alignment requirements as each other.
[6.2.6.1 General] Values stored in unsigned bit-fields and objects of type unsigned char shall be represented using a pure binary notation.
[6.2.6.1 General] A value may be copied into an object of type unsigned char [n] (e.g., by memcpy); the resulting set of bytes is called the object representation of the value.
[6.2.6.1 General] If the stored value of an object has such a representation and is read by an lvalue expression that does not have character type, the behavior is undefined.
[6.2.6.1 General] Certain object representations need not represent a value of the object type. If such a representation is produced by a side effect that modifies all or any part of the object by an lvalue expression that does not have character type, the behavior is undefined.
[6.2.6.1 General] Certain object representations need not represent a value of the object type. Such a representation is called a trap representation.
[6.2.6.1 General] When a value is stored in an object of structure or union type, including in a member object, the bytes of the object representation that correspond to any padding bytes take unspecified values. The value of a structure or union object is never a trap representation, even though the value of a member of the structure or union object may be a trap representation.
[6.2.6.1 General] When a value is stored in a member of an object of union type, the bytes of the object representation that do not correspond to that member but do correspond to other members take unspecified values.
[6.2.6.1 General] Where an operator is applied to a value that has more than one object representation, which object representation is used shall not affect the value of the result. Where a value is stored in an object using a type that has more than one object representation for that value, it is unspecified which representation is used, but a trap representation shall not be generated.
[6.2.6.2 Integer types] For unsigned integer types other than unsigned char, the bits of the object representation shall be divided into two groups: value bits and padding bits (there need not be any of the latter).
[6.2.6.2 Integer types] If there are N value bits in an integer type, each bit shall represent a different power of 2 between 1 and 2^N - 1, so that objects of that type shall be capable of representing values from 0 to 2^N - 1 using a pure binary representation; this shall be known as the value representation.
[6.2.6.2 Integer types] For signed integer types, the bits of the object representation shall be divided into three groups: value bits, padding bits, and the sign bit. There need not be any padding bits; signed char shall not have any padding bits.
[6.2.6.2 Integer types] Signed integer types shall have exactly one sign bit.
[6.2.6.2 Integer types] If the sign bit is one, the value shall be modified in one of the following ways: --the corresponding value with sign bit 0 is negated (sign and magnitude); --the sign bit has the value -(2^M) (two's complement ); --the sign bit has the value -(2^M - 1) (ones' complement). Which of these applies is implementation-defined.
[6.2.6.2 Integer types] It is implementation-defined whether the value with sign bit 1 and all value bits zero (for the first two), or with sign bit and all value bits 1 (for ones' complement), is a trap representation or a normal value. In the case of sign and magnitude and ones' complement, if this representation is a normal value it is called a negative zero.
[6.2.6.2 Integer types] If the implementation supports negative zeros, they shall be generated only by: --the &, |, ^, ~, <<, and >> operators with operands that produce such a value; --the +, -, *, /, and % operators where one operand is a negative zero and the result is zero.
[6.2.6.2 Integer types] If the implementation does not support negative zeros, the behavior of the &, |, ^, ~, <<, and >> operators with operands that would produce such a value is undefined.
[6.2.6.2 Integer types] A valid (non-trap) object representation of a signed integer type where the sign bit is zero is a valid object representation of the corresponding unsigned type, and shall represent the same value.
[6.2.6.2 Integer types] For any integer type, the object representation where all the bits are zero shall be a representation of the value zero in that type.
[6.2.6.2 Integer types] The precision of an integer type is the number of bits it uses to represent values, excluding any sign and padding bits.
[6.2.6.2 Integer types] The width of an integer type is the number of bits it uses to represent values, including any sign and padding bits.
[6.2.7 Compatible type and composite type] For two structures to be compatible, corresponding members shall be declared in the same order.
[6.2.7 Compatible type and composite type] For two structures or unions to be compatible, corresponding bit-fields shall have the same widths.
[6.2.7 Compatible type and composite type] For two enumerations to be compatible, corresponding members shall have the same values.
[6.2.7 Compatible type and composite type] All declarations that refer to the same object or function shall have compatible type; otherwise, the behavior is undefined.
[6.2.7 Compatible type and composite type] A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types.
[6.2.7 Compatible type and composite type] Of two compatible types, if only one type is a function type with a parameter type list (a function prototype), the composite type is a function prototype with the parameter type list.
[6.2.8 Alignment of objects] An alignment is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated.
[6.2.8 Alignment of objects] A fundamental alignment is represented by an alignment less than or equal to the greatest alignment supported by the implementation in all contexts, which is equal to _Alignof (max_align_t).
[6.2.8 Alignment of objects] An extended alignment is represented by an alignment greater than _Alignof (max_align_t).
[6.2.8 Alignment of objects] A type having an extended alignment requirement is an over-aligned type..
[6.2.8 Alignment of objects] Every valid alignment value shall be a nonnegative integral power of two.
[6.2.8 Alignment of objects] An address that satisfies an alignment requirement also satisfies any weaker valid alignment requirement.
[6.2.8 Alignment of objects] The types char, signed char, and unsigned char shall have the weakest alignment requirement.
[6.2.8 Alignment of objects] When an alignment is larger than another it represents a stricter alignment.
[6.3.1.1 Boolean, characters, and integers] No two signed integer types shall have the same integer conversion rank, even if they have the same representation.
[6.3.1.1 Boolean, characters, and integers] The rank of a signed integer type shall be greater than the rank of any signed integer type with less precision.
[6.3.1.1 Boolean, characters, and integers] The rank of long long int shall be greater than the rank of long int, which shall be greater than the rank of int, which shall be greater than the rank of short int, which shall be greater than the rank of signed char.
[6.3.1.1 Boolean, characters, and integers] The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type, if any.
[6.3.1.1 Boolean, characters, and integers] The rank of any standard integer type shall be greater than the rank of any extended integer type with the same width.
[6.3.1.1 Boolean, characters, and integers] The rank of char shall equal the rank of signed char and unsigned char.
[6.3.1.1 Boolean, characters, and integers] The rank of _Bool shall be less than the rank of all other standard integer types.
[6.3.1.1 Boolean, characters, and integers] The rank of any enumerated type shall equal the rank of the compatible integer type.
[6.3.1.1 Boolean, characters, and integers] If an int can represent all values of the original integer type (as restricted by the width, for a bit-field), the value is converted to an int; otherwise, it is converted to an unsigned int. These are called the integer promotions.
[6.3.1.2 Boolean type] When any scalar value is converted to _Bool, the result is 0 if the value compares equal to 0; otherwise, the result is 1..
[6.3.1.3 Signed and unsigned integers] When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged. Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in its range.
[6.3.1.4 Real floating and integer] When a finite value of real floating type is converted to an integer type other than _Bool, the fractional part is discarded (i.e., the value is truncated towards zero). If the value of the integral part cannot be represented by the integer type, the behavior is undefined.
[6.3.1.4 Real floating and integer] If the value of integer type being converted to a real floating type is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner.
[6.3.1.6 Complex types] When a value of complex type is converted to another complex type, both the real and imaginary parts follow the conversion rules for the corresponding real types.
[6.3.1.7 Real and complex] When a value of real type is converted to a complex type, the real part of the complex result value is determined by the rules of conversion to the corresponding real type and the imaginary part of the complex result value is a positive zero or an unsigned zero.
[6.3.1.7 Real and complex] When a value of complex type is converted to a real type, the imaginary part of the complex value is discarded and the value of the real part is converted according to the conversion rules for the corresponding real type.
[6.3.2.1 Lvalues, arrays, and function designators] An lvalue is an expression (with an object type other than void) that potentially designates an object; if an lvalue does not designate an object when it is evaluated, the behavior is undefined.
[6.3.2.1 Lvalues, arrays, and function designators] When an object is said to have a particular type, the type is specified by the lvalue used to designate the object.
[6.3.2.1 Lvalues, arrays, and function designators] A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a const-qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const-qualified type.
[6.3.2.1 Lvalues, arrays, and function designators] An obvious example of an lvalue is an identifier of an object.
[6.3.2.1 Lvalues, arrays, and function designators] Except when it is the operand of the sizeof operator, the _Alignof operator, the unary & operator, the ++ operator, the -- operator, or the left operand of the . operator or an assignment operator, an lvalue that does not have array type is converted to the value stored in the designated object; this is called lvalue conversion.
[6.3.2.1 Lvalues, arrays, and function designators] When an lvalue is converted to a value stored in a designated object, if the lvalue has qualified type, the value has the unqualified version of the type of the lvalue; additionally, if the lvalue has atomic type, the value has the non-atomic version of the type of the lvalue; otherwise, the value has the type of the lvalue.
[6.3.2.1 Lvalues, arrays, and function designators] For an lvalue conversion, if the lvalue designates an object of automatic storage duration that could have been declared with the register storage class (never had its address taken), and that object is uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.
[6.3.2.1 Lvalues, arrays, and function designators] Except when it is the operand of the sizeof operator, the _Alignof operator, or the unary & operator, or is a string literal used to initialize an array, an expression that has type ``array of type'' is converted to an expression with type ``pointer to type'' that points to the initial element of the array object and is not an lvalue.
[6.3.2.1 Lvalues, arrays, and function designators] A function designator is an expression that has function type.
[6.3.2.2 void] The (nonexistent) value of a void expression (an expression that has type void) shall not be used in any way, and implicit or explicit conversions (except to void) shall not be applied to such an expression.
[6.3.2.2 void] If an expression is evaluated as a void expression, its value or designator is discarded.
[6.3.2.3 Pointers] A pointer to any object type may be converted to a pointer to void and back again; the result shall compare equal to the original pointer.
[6.3.2.3 Pointers] For any qualifier q, a pointer to a non-q-qualified type may be converted to a pointer to the q-qualified version of the type; the values stored in the original and converted pointers shall compare equal.
[6.3.2.3 Pointers] An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant. If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function. Any two null pointers shall compare equal.
[6.3.2.3 Pointers] The mapping functions for converting a pointer to an integer or an integer to a pointer are intended to be consistent with the addressing structure of the execution environment.
[6.3.2.3 Pointers] An integer may be converted to any pointer type. The result for an integer other than zero is implementation-defined, might not be correctly aligned, might not point to an entity of the referenced type, and might be a trap representation.
[6.3.2.3 Pointers] When a pointer to an object is converted to a pointer to a character type, the result points to the lowest addressed byte of the object.
[6.3.2.3 Pointers] If a pointer type to A is correctly aligned for a pointer to type B, which in turn is correctly aligned for a pointer to type C, then a pointer to type A is correctly aligned for a pointer to type C.
[6.3.2.3 Pointers] A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer.
[6.3.2.3 Pointers] If a converted pointer is used to call a function whose type is not compatible with the referenced type, the behavior is undefined.
[6.4 Lexical elements] Each preprocessing token that is converted to a token shall have the lexical form of a keyword, an identifier, a constant, a string literal, or a punctuator.
[6.4 Lexical elements] A token is the minimal lexical element of the language in translation phases 7 and 8.
[6.4 Lexical elements] A preprocessing token is the minimal lexical element of the language in translation phases 3 through 6.
[6.4 Lexical elements] If the input stream has been parsed into preprocessing tokens up to a given character, the next preprocessing token is the longest sequence of characters that could constitute a preprocessing token.
[6.4.2.1 General] An identifier is a sequence of nondigit characters (including the underscore _, the lowercase and uppercase Latin letters, and other characters) and digits, which designates one or more entities.
[6.4.2.1 General] An implementation may allow multibyte characters that are not part of the basic source character set to appear in identifiers; which characters and their correspondence to universal character names is implementation-defined.
[6.4.2.1 General] When preprocessing tokens are converted to tokens during translation phase 7, if a preprocessing token could be converted to either a keyword or an identifier, it is converted to a keyword.
[6.4.2.1 General] If two identifiers differ only in nonsignificant characters, the behavior is undefined.
[6.4.2.2 Predefined identifiers] The identifier __func__ shall be implicitly declared by the translator as if, immediately following the opening brace of each function definition, the declaration static const char __func__[] = "function-name"; appeared, where function-name is the name of the lexically-enclosing function.
[6.4.3 Universal character names] A universal character name shall not specify a character whose short identifier is less than 00A0 other than 0024 ($), 0040 (@), or 0060 (`), nor one in the range D800 through DFFF inclusive.
[6.4.4 Constants] Each constant shall have a type and the value of a constant shall be in the range of representable values for its type.
[6.4.4.1 Integer constants] A decimal constant begins with a nonzero digit and consists of a sequence of decimal digits.
[6.4.4.1 Integer constants] An octal constant consists of the prefix 0 optionally followed by a sequence of the digits 0 through 7 only.
[6.4.4.1 Integer constants] A hexadecimal constant consists of the prefix 0x or 0X followed by a sequence of the decimal digits and the letters a (or A) through f (or F) with values 10 through 15 respectively.
[6.4.4.1 Integer constants] If an integer constant cannot be represented by any type in its list, it may have an extended integer type, if the extended integer type can represent its value.
[6.4.4.1 Integer constants] If an integer constant cannot be represented by any type in its list and has no extended integer type, then the integer constant has no type.
[6.4.4.2 Floating constants] If a floating constant is suffixed by the letter f or F, it has type float.
[6.4.4.2 Floating constants] If a floating constant is suffixed by the letter l or L, it has type long double.
[6.4.4.2 Floating constants] The conversion of a floating constant shall not raise an exceptional condition or a floating-point exception at execution time.
[6.4.4.3 Enumeration constants] An identifier declared as an enumeration constant has type int.
[6.4.4.4 Character constants] An integer character constant is a sequence of one or more multibyte characters enclosed in single-quotes.
[6.4.4.4 Character constants] A wide character constant is a sequence of one or more multibyte characters enclosed in single-quotes and prefixed by the letter L, u, or U.
[6.4.4.4 Character constants] In a character constant, the double-quote " and question-mark ? are representable either by themselves or by the escape sequences \" and \?, respectively, but the single-quote ' and the backslash \ shall be represented, respectively, by the escape sequences \' and \\.
[6.4.4.4 Character constants] The value of an octal or hexadecimal escape sequence in a character constant shall be in the range of representable values for the type unsigned char if not prefixed.
[6.4.4.4 Character constants] The value of an octal or hexadecimal escape sequence in a character constant shall be in the range of representable values for the unsigned type corresponding to wchar_t if prefixed with L.
[6.4.4.4 Character constants] The value of an octal or hexadecimal escape sequence in a character constant shall be in the range of representable values for the type char16_t if prefixed with u.
[6.4.4.4 Character constants] The value of an octal or hexadecimal escape sequence in a character constant shall be in the range of representable values for the type char32_t if prefixed with U.
[6.4.4.4 Character constants] If an integer character constant contains a single character or escape sequence, its value is the one that results when an object with type char whose value is that of the single character or escape sequence is converted to type int.
[6.4.5 String literals] A sequence of adjacent string literal tokens shall not include both a wide string literal and a UTF-8 string literal.
[6.4.5 String literals] A character string literal is a sequence of zero or more multibyte characters enclosed in double-quotes.
[6.4.5 String literals] A UTF-8 string literal is a sequence of zero or more multibyte characters enclosed in double-quotes and prefixed by u8.
[6.4.5 String literals] A wide string literal is a sequence of zero or more multibyte characters enclosed in double-quotes and  prefixed by the letter L, u, or U.
[6.4.5 String literals] In translation phase 6, the multibyte character sequences specified by any sequence of adjacent character and identically-prefixed string literal tokens are concatenated into a single multibyte character sequence.
[6.4.5 String literals] When adjacent string literals are concatenated together in translation phase 6, if any of the tokens has an encoding prefix, the resulting multibyte character sequence is treated as having the same prefix; otherwise, it is treated as a character string literal.
[6.4.5 String literals] If the program attempts to modify a string literal, the behavior is undefined.
[6.4.6 Punctuators] A punctuator may specify an operation to be performed (which in turn may yield a value or a function designator, produce a side effect, or some combination thereof) in which case it is known as an operator.
[6.4.6 Punctuators] An operand is an entity on which an operator acts.
[6.4.6 Punctuators] The following tokens, <: :> <% %> %: and %:%:, are known as digraphs.
[6.4.7 Header names] If the characters ', \, ", //, or /* occur in the sequence between the < and > delimiters of an #include directive, the behavior is undefined.
[6.5 Expressions] An expression is a sequence of operators and operands that specifies computation of a value, or that designates an object or a function, or that generates side effects, or that performs a combination thereof.
[6.5 Expressions] If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.
[6.5 Expressions] If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.
[6.5 Expressions] The syntax of the grouping of operators and operands specifies the precedence of operators in the evaluation of an expression.
[6.5 Expressions] The unary operator ~, and the binary operators <<, >>, &, ^, and | are collectively described as bitwise operators.
[6.5 Expressions] The result of the unary ~ operator is the bitwise complement of its operand.
[6.5 Expressions] The result of the binary << operator is its left operand shifted the number of bit positions left designated by its right operand.
[6.5 Expressions] The result of the binary >> operator is its left operand shifted the number of bit positions right designated by its right operand.
[6.5 Expressions] The result of the binary & operator is the bitwise-AND of its operands.
[6.5 Expressions] The result of the binary ^ operator is the exclusive-OR of its operands.
[6.5 Expressions] The result of the binary | operator is the bitwise-OR of its operands.
[6.5 Expressions] The bitwise operators are required to have operands that have integer type.
[6.5 Expressions] If the result of the evaluation of an expression is not mathematically defined or not in the range of representable values for its type, an exceptional condition occurs.
[6.5 Expressions] If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or not in the range of representable values for its type), the behavior is undefined.
[6.5 Expressions] If a value is stored into an object having no declared type through an lvalue having a type that is not a character type, then the type of the lvalue becomes the effective type of the object for that access and for subsequent accesses that do not modify the stored value.
[6.5 Expressions] If a value is copied into an object having no declared type using memcpy or memmove, or is copied as an array of character type, then the effective type of the modified object for that access and for subsequent accesses that do not modify the value is the effective type of the object from which the value is copied, if it has one.
[6.5 Expressions] A floating expression may be contracted, that is, evaluated as though it were a single operation, thereby omitting rounding errors implied by the source code and the expression evaluation method. The FP_CONTRACT pragma in <math.h> provides a way to disallow contracted expressions. A contracted expression might also omit the raising of floating-point exceptions.
[6.5.1.1 Generic selection] A generic selection shall have no more than one default generic association.
[6.5.1.1 Generic selection] The type name in a generic association shall specify a complete object type other than a variably modified type.
[6.5.1.1 Generic selection] No two generic associations in the same generic selection shall specify compatible types.
[6.5.1.1 Generic selection] The controlling expression of a generic selection shall have type compatible with at most one of the types named in its generic association list.
[6.5.1.1 Generic selection] If a generic selection has no default generic association, its controlling expression shall have type compatible with exactly one of the types named in its generic association list.
[6.5.1.1 Generic selection] If a generic selection has a generic association with a type name that is compatible with the type of the controlling expression, then the result expression of the generic selection is the expression in that generic association.
[6.5.2.1 Array subscripting] One of the expressions of an array subscript shall have type ``pointer to complete object type'', the other expression shall have integer type, and the result has type ``type''.
[6.5.2.1 Array subscripting] A postfix expression followed by an expression in square brackets [] is a subscripted designation of an element of an array object.
[6.5.2.1 Array subscripting] The expression x[i] is equivalent to (*((x)+(i))).
[6.5.2.2 Function calls] The expression that denotes the called function shall have type pointer to function returning void or returning a complete object type other than an array type.
[6.5.2.2 Function calls] If the expression that denotes the called function has a type that includes a prototype, the number of arguments shall agree with the number of parameters.
[6.5.2.2 Function calls] A postfix expression followed by parentheses () containing a possibly empty, comma-separated list of expressions is a function call.
[6.5.2.2 Function calls] If the expression that denotes the called function has a type that does not include a prototype, the integer promotions are performed on each argument, and arguments that have type float are promoted to double. These are called the default argument promotions.
[6.5.2.2 Function calls] If the expression that denotes the called function has a type that does include a prototype, the arguments are implicitly converted, as if by assignment, to the types of the corresponding parameters, taking the type of each parameter to be the unqualified version of its declared type.
[6.5.2.2 Function calls] If the function is defined with a type that is not compatible with the type (of the expression) pointed to by the expression that denotes the called function, the behavior is undefined.
[6.5.2.2 Function calls] Recursive function calls shall be permitted, both directly and indirectly through any chain of other functions.
[6.5.2.2 Function calls] In the function call (*pf[f1()]) (f2(), f3() + f4()) the functions f1, f2, f3, and f4 may be called in any order. All side effects have to be completed before the function pointed to by pf[f1()] is called.
[6.5.2.3 Structure and union members] The first operand of the . operator shall have an atomic, qualified, or unqualified structure or union type, and the second operand shall name a member of that type.
[6.5.2.3 Structure and union members] The first operand of the -> operator shall have type ``pointer to atomic, qualified, or unqualified structure'' or ``pointer to atomic, qualified, or unqualified union'', and the second operand shall name a member of the type pointed to.
[6.5.2.3 Structure and union members] If the member used to read the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type (a process sometimes called ``type punning'').
[6.5.2.4 Postfix increment and decrement operators] The operand of the postfix increment or decrement operator shall have atomic, qualified, or unqualified real or pointer type, and shall be a modifiable lvalue.
[6.5.2.4 Postfix increment and decrement operators] The result of the postfix ++ operator is the value of the operand. As a side effect, the value of the operand object is incremented.
[6.5.2.4 Postfix increment and decrement operators] The result of the postfix -- operator is the value of the operand. As a side effect, the value of the operand object is decremented.
[6.5.2.5 Compound literals] The type name of a compound literal shall specify a complete object type or an array of unknown size, but not a variable length array type.
[6.5.2.5 Compound literals] A postfix expression that consists of a parenthesized type name followed by a brace-enclosed list of initializers is called a compound literal.
[6.5.2.5 Compound literals] If the type name specifies an array of unknown size, the size is determined by the initializer list, and the type of the compound literal is that of the completed array type.
[6.5.2.5 Compound literals] If a compound literal occurs outside the body of a function, the object has static storage duration; otherwise, it has automatic storage duration associated with the enclosing block.
[6.5.3.1 Prefix increment and decrement operators] The operand of the prefix increment or decrement operator shall have atomic, qualified, or unqualified real or pointer type, and shall be a modifiable lvalue.
[6.5.3.1 Prefix increment and decrement operators] The value of the operand of the prefix ++ operator is incremented. The result is the new value of the operand after incrementation.
[6.5.3.1 Prefix increment and decrement operators] The value of the operand of the prefix -- operator is decremented. The result is the new value of the operand after decrementation.
[6.5.3.2 Address and indirection operators] The operand of the unary & operator shall be either a function designator, the result of a [] or unary * operator, or an lvalue that designates an object that is not a bit-field and is not declared with the register storage-class specifier.
[6.5.3.2 Address and indirection operators] The operand of the unary * operator shall have pointer type.
[6.5.3.2 Address and indirection operators] The unary & operator yields the address of its operand.
[6.5.3.2 Address and indirection operators] If the operand of the unary & operator has type ``type'', the result has type ``pointer to type''.
[6.5.3.2 Address and indirection operators] If the operand of the unary & operator is the result of a unary * operator, neither that operator nor the & operator is evaluated and the result is as if both were omitted, except that the constraints on the operators still apply and the result is not an lvalue.
[6.5.3.2 Address and indirection operators] The result of the unary & operator is a pointer to the object or function designated by its operand.
[6.5.3.2 Address and indirection operators] If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object.
[6.5.3.2 Address and indirection operators] The unary * operator denotes indirection.
[6.5.3.2 Address and indirection operators] If the operand of the unary * operator has type ``pointer to type'', the result has type ``type''.
[6.5.3.2 Address and indirection operators] If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.
[6.5.3.2 Address and indirection operators] If *P is an lvalue and T is the name of an object pointer type, *(T)P is an lvalue that has a type compatible with that to which T points.
[6.5.3.3 Unary arithmetic operators] The operand of the unary + or - operator shall have arithmetic type; of the ~ operator, integer type; of the ! operator, scalar type.
[6.5.3.3 Unary arithmetic operators] If the type of the ~ operator is an unsigned type, the expression ~E is equivalent to the maximum value representable in that type minus E.
[6.5.3.4 The sizeof and _Alignof operators] The sizeof operator shall not be applied to an expression that has function type or an incomplete type, to the parenthesized name of such a type, or to an expression that designates a bit-field member.
[6.5.3.4 The sizeof and _Alignof operators] The _Alignof operator shall not be applied to a function type or an incomplete type.
[6.5.3.4 The sizeof and _Alignof operators] If the type of the operand is a variable length array type, the operand is evaluated; otherwise, the operand is not evaluated and the result is an integer constant.
[6.5.3.4 The sizeof and _Alignof operators] When the _Alignof operator is applied to an array type, the result is the alignment requirement of the element type.
[6.5.3.4 The sizeof and _Alignof operators] When sizeof is applied to an operand that has type char, unsigned char, or signed char, (or a qualified version thereof) the result is 1.
[6.5.3.4 The sizeof and _Alignof operators] When the sizeof operator is applied to an operand that has array type, the result is the total number of bytes in the array. When applied to an operand that has structure or union type, the result is the total number of bytes in such an object, including internal and trailing padding.
[6.5.3.4 The sizeof and _Alignof operators] When applied to a parameter declared to have array or function type, the sizeof operator yields the size of the adjusted (pointer) type.
[6.5.3.4 The sizeof and _Alignof operators] A principal use of the sizeof operator is in communication with routines such as storage allocators and I/O systems.
[6.5.4 Cast operators] Unless the type name specifies a void type, the type name shall specify atomic, qualified, or unqualified scalar type, and the operand shall have scalar type.
[6.5.4 Cast operators] Conversions that involve pointers, except where permitted by the constraints of simple assignment, shall be specified by means of an explicit cast.
[6.5.4 Cast operators] A pointer type shall not be converted to any floating type.
[6.5.4 Cast operators] A floating type shall not be converted to any pointer type.
[6.5.4 Cast operators] Preceding an expression by a parenthesized type name converts the value of the expression to the named type. This construction is called a cast. A cast that specifies no conversion has no effect on the type or value of an expression.
[6.5.4 Cast operators] If the value of the expression is represented with greater range or precision than required by the type named by the cast, then the cast specifies a conversion even if the type of the expression is the same as the named type and removes any extra range and precision.
[6.5.5 Multiplicative operators] Each of the operands of multiplicative operators shall have arithmetic type.
[6.5.5 Multiplicative operators] The operands of the % operator shall have integer type.
[6.5.5 Multiplicative operators] The result of the binary * operator is the product of the operands.
[6.5.5 Multiplicative operators] The result of the / operator is the quotient from the division of the first operand by the second; the result of the % operator is the remainder. In both operations, if the value of the second operand is zero, the behavior is undefined.
[6.5.5 Multiplicative operators] When integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded (this is often called ``truncation toward zero''). If the quotient a/b is representable, the expression (a/b)*b + a%b shall equal a; otherwise, the behavior of both a/b and a%b is undefined.
[6.5.6 Additive operators] For addition, either both operands shall have arithmetic type, or one operand shall be a pointer to a complete object type and the other shall have integer type.
[6.5.6 Additive operators] For subtraction, one of the following shall hold: --both operands have arithmetic type; --both operands are pointers to qualified or unqualified versions of compatible complete object types; or --the left operand is a pointer to a complete object type and the right operand has integer type.
[6.5.6 Additive operators] When an expression that has integer type is added to or subtracted from a pointer, the result has the type of the pointer operand.
[6.5.6 Additive operators] If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integer expression.
[6.5.6 Additive operators] If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.
[6.5.6 Additive operators] If the result points one past the last element of the array object, it shall not be used as the operand of a unary * operator that is evaluated.
[6.5.6 Additive operators] When two pointers are subtracted, both shall point to elements of the same array object, or one past the last element of the array object; the result is the difference of the subscripts of the two array elements.
[6.5.7 Bitwise shift operators] Each of the operands for the bitwise shift operators shall have integer type.
[6.5.7 Bitwise shift operators] If the value of the right operand of a bitwise shift operator is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.
[6.5.7 Bitwise shift operators] The result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros.
[6.5.7 Bitwise shift operators] The result of E1 << E2 is E1 left-shifted E2 bit positions. If E1 has a signed type and a negative value, the resulting value is implementation-defined.
[6.5.8 Relational operators] When two pointers are compared, the result depends on the relative locations in the address space of the objects pointed to.
[6.5.8 Relational operators] If two pointers to object types both point to the same object, or both point one past the last element of the same array object, they compare equal.
[6.5.8 Relational operators] If the objects pointed to are members of the same aggregate object, pointers to structure members declared later compare greater than pointers to members declared earlier in the structure, and pointers to array elements with larger subscript values compare greater than pointers to elements of the same array with lower subscript values.
[6.5.8 Relational operators] If the expression P points to an element of an array object and the expression Q points to the last element of the same array object, the pointer expression Q+1 compares greater than P.
[6.5.8 Relational operators] Each of the operators < (less than), > (greater than), <= (less than or equal to), and >= (greater than or equal to) shall yield 1 if the specified relation is true and 0 if it is false. The result has type int.
[6.5.9 Equality operators] One of the following shall hold: --both operands have arithmetic type; --both operands are pointers to qualified or unqualified versions of compatible types; --one operand is a pointer to an object type and the other is a pointer to a qualified or unqualified version of void; or --one operand is a pointer and the other is a null pointer constant.
[6.5.9 Equality operators] If one operand is a pointer and the other is a null pointer constant, the null pointer constant is converted to the type of the pointer.
[6.5.9 Equality operators] If one operand is a pointer to an object type and the other is a pointer to a qualified or unqualified version of void, the former is converted to the type of the latter.
[6.5.9 Equality operators] If prior invalid pointer operations (such as accesses outside array bounds) produced undefined behavior, subsequent comparisons also produce undefined behavior.
[6.5.9 Equality operators] Two pointers compare equal if one is a pointer to one past the end of one array object and the other is a pointer to the start of a different array object that happens to immediately follow the first array object in the address space.
[6.5.13 Logical AND operator] Each of the operands of && operator shall have scalar type.
[6.5.13 Logical AND operator] The && operator shall yield 1 if both of its operands compare unequal to 0; otherwise, it yields 0.
[6.5.13 Logical AND operator] If the first operand of the && operator compares equal to 0, the second operand is not evaluated.
[6.5.14 Logical OR operator] Each of the operands of the || operator shall have scalar type.
[6.5.14 Logical OR operator] The || operator shall yield 1 if either of its operands compare unequal to 0; otherwise, it yields 0.
[6.5.14 Logical OR operator] If the first operand of the || operator compares unequal to 0, the second operand is not evaluated.
[6.5.15 Conditional operator] The first operand of the ?: operator shall have scalar type.
[6.5.15 Conditional operator] One of the following shall hold for the second and third operands of the ?: operator: both operands have arithmetic type; both operands have the same structure or union type; both operands have void type; both operands are pointers to compatible types; one operand is a pointer and the other is a null pointer constant or pointer to void.
[6.5.15 Conditional operator] If both the second and third operands of the ?: operator have arithmetic type, the result type that would be determined by the usual arithmetic conversions, were they applied to those two operands, is the type of the result.
[6.5.15 Conditional operator] If both the second and third operands of the ?: operator have structure or union type, the result has that type.
[6.5.15 Conditional operator] If both the second and third operands of the ?: operator have void type, the result has void type.
[6.5.15 Conditional operator] If both the second and third operands are pointers or one is a null pointer constant and the other is a pointer, the result type is a pointer to a type qualified with all the type qualifiers of the types referenced by both operands.
[6.5.16 Assignment operators] An assignment operator shall have a modifiable lvalue as its left operand.
[6.5.16 Assignment operators] An assignment expression has the value of the left operand after the assignment, but is not an lvalue.
[6.5.16.1 Simple assignment] If the value being stored in an object is read from another object that overlaps in any way the storage of the first object, then the overlap shall be exact and the two objects shall have qualified or unqualified versions of a compatible type; otherwise, the behavior is undefined.
[6.5.16.2 Compound assignment] For the operators += and -= only, either the left operand shall be an atomic, qualified, or unqualified pointer to a complete object type, and the right shall have integer type; or the left operand shall have atomic, qualified, or unqualified arithmetic type, and the right shall have arithmetic type.
[6.5.16.2 Compound assignment] For the compound assignment operators other than += and -=, the left operand shall have atomic, qualified, or unqualified arithmetic type, and (considering the type the left operand would have after lvalue conversion) each operand shall have arithmetic type consistent with those allowed by the corresponding binary operator.
[6.5.16.2 Compound assignment] A compound assignment of the form E1 op = E2 is equivalent to the simple assignment expression E1 = E1 op (E2), except that the lvalue E1 is evaluated only once, and with respect to an indeterminately-sequenced function call, the operation of a compound assignment is a single evaluation.
[6.5.16.2 Compound assignment] For a compound assignment of the form E1 op = E2, if E1 or E2 has floating type, then exceptional conditions or floating-point exceptions encountered during discarded evaluations of new should also be discarded in order to satisfy the equivalence of E1 op = E2 and E1 = E1 op (E2).
[6.6 Constant expressions] Constant expressions shall not contain assignment, increment, decrement, function-call, or comma operators, except when they are contained within a subexpression that is not evaluated.
[6.6 Constant expressions] Each constant expression shall evaluate to a constant that is in the range of representable values for its type.
[6.6 Constant expressions] If a floating expression is evaluated in the translation environment, the arithmetic range and precision shall be at least as great as if the expression were being evaluated in the execution environment.
[6.6 Constant expressions] An integer constant expression shall have integer type and shall only have operands that are integer constants, enumeration constants, character constants, sizeof expressions whose results are integer constants, _Alignof expressions, and floating constants that are the immediate operands of casts.
[6.6 Constant expressions] Cast operators in an integer constant expression shall only convert arithmetic types to integer types, except as part of an operand to the sizeof or _Alignof operator.
[6.6 Constant expressions] An integer constant expression is required in a number of contexts such as the size of a bit-field member of a structure, the value of an enumeration constant, and the size of a non-variable length array.
[6.6 Constant expressions] Constant expressions in initializers shall be, or evaluate to, one of the following: --an arithmetic constant expression, --a null pointer constant, --an address constant, or --an address constant for a complete object type plus or minus an integer constant expression.
[6.6 Constant expressions] An arithmetic constant expression shall have arithmetic type and shall only have operands that are integer constants, floating constants, enumeration constants, character constants, sizeof expressions whose results are integer constants, and _Alignof expressions.
[6.6 Constant expressions] Cast operators in an arithmetic constant expression shall only convert arithmetic types to arithmetic types, except as part of an operand to a sizeof or _Alignof operator.
[6.6 Constant expressions] An address constant is a null pointer, a pointer to an lvalue designating an object of static storage duration, or a pointer to a function designator; it shall be created explicitly using the unary & operator or an integer constant cast to pointer type, or implicitly by the use of an expression of array or function type.
[6.6 Constant expressions] The array-subscript [] and member-access . and -> operators, the address & and indirection * unary operators, and pointer casts may be used in the creation of an address constant, but the value of an object shall not be accessed by use of these operators.
[6.7 Declarations] A declaration other than a static_assert declaration shall declare at least a declarator (other than the parameters of a function or the members of a structure or union), a tag, or the members of an enumeration.
[6.7 Declarations] If an identifier has no linkage, there shall be no more than one declaration of the identifier (in a declarator or type specifier) with the same scope and in the same name space, except that: --a typedef name may be redefined to denote the same type as it currently does, provided that type is not a variably modified type; --tags may be redeclared as allowed.
[6.7 Declarations] All declarations in the same scope that refer to the same object or function shall specify compatible types.
[6.7 Declarations] A definition of an identifier is a declaration for that identifier that: --for an object, causes storage to be reserved for that object; --for a function, includes the function body; --for an enumeration constant, is the (only) declaration of the identifier; --for a typedef name, is the first (or only) declaration of the identifier.
[6.7 Declarations] If an identifier for an object is declared with no linkage, the type for the object shall be complete by the end of its declarator, or by the end of its init-declarator if it has an initializer; in the case of function parameters (including in prototypes), it is the adjusted type that is required to be complete.
[6.7.1 Storage-class specifiers] In the declaration of an object with block scope, if the declaration specifiers include _Thread_local, they shall also include either static or extern.
[6.7.1 Storage-class specifiers] If _Thread_local appears in any declaration of an object, it shall be present in every declaration of that object.
[6.7.1 Storage-class specifiers] _Thread_local shall not appear in the declaration specifiers of a function declaration.
[6.7.1 Storage-class specifiers] The typedef specifier is called a ``storage-class specifier'' for syntactic convenience only.
[6.7.1 Storage-class specifiers] A declaration of an identifier for an object with storage-class specifier register suggests that access to the object be as fast as possible.
[6.7.1 Storage-class specifiers] The declaration of an identifier for a function that has block scope shall have no explicit storage-class specifier other than extern.
[6.7.1 Storage-class specifiers] If an aggregate or union object is declared with a storage-class specifier other than typedef, the properties resulting from the storage-class specifier, except with respect to linkage, also apply to the members of the object, and so on recursively for any aggregate or union member objects.
[6.7.2 Type specifiers] At least one type specifier shall be given in the declaration specifiers in each declaration, and in the specifier-qualifier list in each struct declaration and type name.
[6.7.2 Type specifiers] The type specifier _Complex shall not be used if the implementation does not support complex types. 
[6.7.2.1 Structure and union specifiers] A struct-declaration that does not declare an anonymous structure or anonymous union shall contain a struct-declarator-list.
[6.7.2.1 Structure and union specifiers] A structure or union shall not contain a member with incomplete or function type (hence, a structure shall not contain an instance of itself, but may contain a pointer to an instance of itself), except that the last member of a structure with more than one named member may have incomplete array type.
[6.7.2.1 Structure and union specifiers] A structure containing a flexible array member (or union containing, possibly recursively, a member that is such a structure) shall not be a member of a structure or an element of an array.
[6.7.2.1 Structure and union specifiers] The expression that specifies the width of a bit-field shall be an integer constant expression with a nonnegative value that does not exceed the width of an object of the type that would be specified were the colon and expression omitted. If the value is zero, the declaration shall have no declarator.
[6.7.2.1 Structure and union specifiers] A bit-field shall have a type that is a qualified or unqualified version of _Bool, signed int, unsigned int, or some other implementation-defined type.
[6.7.2.1 Structure and union specifiers] If the struct-declaration-list does not contain any named members, either directly or via an anonymous structure or anonymous union, the behavior is undefined.
[6.7.2.1 Structure and union specifiers] A structure or union may have a member declared to consist of a specified number of bits. Such a member is called a bit-field.
[6.7.2.1 Structure and union specifiers] A bit-field is interpreted as having a signed or unsigned integer type consisting of the specified number of bits. If the value 0 or 1 is stored into a nonzero-width bit-field of type _Bool, the value of the bit-field shall compare equal to the value stored; a _Bool bit-field has the semantics of a _Bool.
[6.7.2.1 Structure and union specifiers] If enough space remains, a bit-field that immediately follows another bit-field in a structure shall be packed into adjacent bits of the same unit.
[6.7.2.1 Structure and union specifiers] If insufficient space remains, whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is implementation-defined.
[6.7.2.1 Structure and union specifiers] An unnamed bit-field structure member is useful for padding to conform to externally imposed layouts.
[6.7.2.1 Structure and union specifiers] An unnamed member whose type specifier is a structure specifier with no tag is called an anonymous structure.
[6.7.2.1 Structure and union specifiers] An unnamed member whose type specifier is a union specifier with no tag is called an anonymous union.
[6.7.2.1 Structure and union specifiers] A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa.
[6.7.2.1 Structure and union specifiers] A pointer to a union object, suitably converted, points to each of its members (or if a member is a bit-field, then to the unit in which it resides), and vice versa.
[6.7.2.1 Structure and union specifiers] There may be unnamed padding within a structure object, but not at its beginning.
[6.7.2.1 Structure and union specifiers] As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member.
[6.7.2.1 Structure and union specifiers] If a flexible array member would have no elements, it behaves as if it had one element but the behavior is undefined if any attempt is made to access that element or to generate a pointer one past it.
[6.7.2.2 Enumeration specifiers] The expression that defines the value of an enumeration constant shall be an integer constant expression that has a value representable as an int.
[6.7.2.2 Enumeration specifiers] If the first enumerator has no =, the value of its enumeration constant is 0.
[6.7.2.2 Enumeration specifiers] Each enumerated type shall be compatible with char, a signed integer type, or an unsigned integer type. The choice of type is implementation-defined, but shall be capable of representing the values of all the members of the enumeration.
[6.7.2.3 Tags] Where two declarations that use the same tag declare the same type, they shall both use the same choice of struct, union, or enum.
[6.7.2.3 Tags] A type specifier of the form enum identifier without an enumerator list shall only appear after the type it specifies is complete.
[6.7.2.3 Tags] An incomplete type may only by used when the size of an object of that type is not needed.
[6.7.2.4 Atomic type specifiers] Atomic type specifiers shall not be used if the implementation does not support atomic types.
[6.7.2.4 Atomic type specifiers] The type name in an atomic type specifier shall not refer to an array type, a function type, an atomic type, or a qualified type.
[6.7.2.4 Atomic type specifiers] If the _Atomic keyword is immediately followed by a left parenthesis, it is interpreted as a type specifier (with a type name), not as a type qualifier.
[6.7.3 Type qualifiers] Types other than pointer types whose referenced type is an object type shall not be restrict-qualified.
[6.7.3 Type qualifiers] The type modified by the _Atomic qualifier shall not be an array type or a function type.
[6.7.3 Type qualifiers] If the same qualifier appears more than once in the same specifier-qualifier-list, either directly or via one or more typedefs, the behavior is the same as if it appeared only once.
[6.7.3 Type qualifiers] If other qualifiers appear along with the _Atomic qualifier in a specifier-qualifier-list, the resulting type is the so-qualified atomic type.
[6.7.3 Type qualifiers] If an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, the behavior is undefined.
[6.7.3 Type qualifiers] If an attempt is made to refer to an object defined with a volatile-qualified type through use of an lvalue with non-volatile-qualified type, the behavior is undefined.
[6.7.3 Type qualifiers] What constitutes an access to an object that has volatile-qualified type is implementation-defined.
[6.7.3 Type qualifiers] Actions on objects declared as volatile shall not be ``optimized out'' by an implementation or reordered except as permitted by the rules for evaluating expressions.
[6.7.3 Type qualifiers] An object that is accessed through a restrict-qualified pointer has a special association with that pointer. This association requires that all accesses to that object use, directly or indirectly, the value of that particular pointer. The intended use of the restrict qualifier is to promote optimization.
[6.7.3 Type qualifiers] If the specification of an array type includes any type qualifiers, the element type is so-qualified, not the array type.
[6.7.3 Type qualifiers] If the specification of a function type includes any type qualifiers, the behavior is undefined.
[6.7.3 Type qualifiers] For two qualified types to be compatible, both shall have the identically qualified version of a compatible type; the order of type qualifiers within a list of specifiers or qualifiers does not affect the specified type.
[6.7.3.1 Formal definition of restrict] A translator is free to ignore any or all aliasing implications of uses of restrict.
[6.7.4 Function specifiers] Function specifiers shall be used only in the declaration of an identifier for a function.
[6.7.4 Function specifiers] An inline definition of a function with external linkage shall not contain a definition of a modifiable object with static or thread storage duration, and shall not contain a reference to an identifier with internal linkage.
[6.7.4 Function specifiers] In a hosted environment, no function specifier(s) shall appear in a declaration of main.
[6.7.4 Function specifiers] A function specifier may appear more than once; the behavior is the same as if it appeared only once.
[6.7.4 Function specifiers] A function declared with an inline function specifier is an inline function.
[6.7.4 Function specifiers] If a function with external linkage is declared with an inline function specifier, then it shall also be defined in the same translation unit.
[6.7.4 Function specifiers] If all of the file scope declarations for a function in a translation unit include the inline function specifier without extern, then the definition in that translation unit is an inline definition.
[6.7.4 Function specifiers] A function declared with a _Noreturn function specifier shall not return to its caller.
[6.7.5 Alignment specifier] An alignment attribute shall not be specified in a declaration of a typedef, or a bit-field, or a function, or a parameter, or an object declared with the register storage-class specifier.
[6.7.5 Alignment specifier] The constant expression to the _Alignas specifier shall be an integer constant expression. It shall evaluate to a valid fundamental alignment, or to a valid extended alignment supported by the implementation in the context in which it appears, or to zero.
[6.7.5 Alignment specifier] The combined effect of all alignment attributes in a declaration shall not specify an alignment that is less strict than the alignment that would otherwise be required for the type of the object or member being declared.
[6.7.5 Alignment specifier] When multiple alignment specifiers occur in a declaration, the effective alignment requirement is the strictest specified alignment.
[6.7.5 Alignment specifier] If the definition of an object has an alignment specifier, any other declaration of that object shall either specify equivalent alignment or have no alignment specifier.
[6.7.5 Alignment specifier] If the definition of an object does not have an alignment specifier, any other declaration of that object shall also have no alignment specifier.
[6.7.5 Alignment specifier] If declarations of an object in different translation units have different alignment specifiers, the behavior is undefined.
[6.7.6 Declarators] A full declarator is a declarator that is not part of another declarator.
[6.7.6 Declarators] If, in the nested sequence of declarators in a full declarator, there is a declarator specifying a variable length array type, the type specified by the full declarator is said to be variably modified.
[6.7.6.1 Pointer declarators] For two pointer types to be compatible, both shall be identically qualified and both shall be pointers to compatible types.
[6.7.6.1 Pointer declarators] const int *ptr_to_constant; int *const constant_ptr; The contents of any object pointed to by ptr_to_constant shall not be modified through that pointer, but ptr_to_constant itself may be changed to point to another object. Similarly, the contents of the int pointed to by constant_ptr may be modified, but constant_ptr itself shall always point to the same location.
[6.7.6.2 Array declarators] The element type of an array shall not be an incomplete or function type.
[6.7.6.2 Array declarators] If an identifier is declared as having a variably modified type, it shall be an ordinary identifier, have no linkage, and have either block scope or function prototype scope.
[6.7.6.2 Array declarators] If an identifier is declared to be an object with static or thread storage duration, it shall not have a variable length array type.
[6.7.6.2 Array declarators] When several ``array of'' specifications are adjacent, a multidimensional array is declared.
[6.7.6.2 Array declarators] If the size is not present, the array type is an incomplete type.
[6.7.6.2 Array declarators] If the size is * instead of being an expression, the array type is a variable length array type of unspecified size, which can only be used in declarations or type names with function prototype scope; such arrays are nonetheless complete types.
[6.7.6.2 Array declarators] If the size of an array is an integer constant expression and the element type has a known constant size, the array type is not a variable length array type; otherwise, the array type is a variable length array type.
[6.7.6.2 Array declarators] If the size is an expression that is not an integer constant expression: if it occurs in a declaration at function prototype scope, it is treated as if it were replaced by *; otherwise, each time it is evaluated it shall have a value greater than zero.
[6.7.6.2 Array declarators] For two array types to be compatible, both shall have compatible element types, and if both size specifiers are present, and are integer constant expressions, then both size specifiers shall have the same constant value.
[6.7.6.2 Array declarators] If the two array types are used in a context which requires them to be compatible, it is undefined behavior if the two size specifiers evaluate to unequal values.
[6.7.6.3 Function declarators (including prototypes)] A function declarator shall not specify a return type that is a function type or an array type.
[6.7.6.3 Function declarators (including prototypes)] The only storage-class specifier that shall occur in a parameter declaration is register.
[6.7.6.3 Function declarators (including prototypes)] An identifier list in a function declarator that is not part of a definition of that function shall be empty.
[6.7.6.3 Function declarators (including prototypes)] After adjustment, the parameters in a parameter type list in a function declarator that is part of a definition of that function shall not have incomplete type.
[6.7.6.3 Function declarators (including prototypes)] A parameter type list specifies the types of, and may declare identifiers for, the parameters of the function.
[6.7.6.3 Function declarators (including prototypes)] A declaration of a parameter as ``array of type'' shall be adjusted to ``qualified pointer to type'', where the type qualifiers (if any) are those specified within the [ and ] of the array type derivation.
[6.7.6.3 Function declarators (including prototypes)] If the keyword static also appears within the [ and ] of the array type derivation, then for each call to the function, the value of the corresponding actual argument shall provide access to the first element of an array with at least as many elements as specified by the size expression.
[6.7.6.3 Function declarators (including prototypes)] A declaration of a parameter as ``function returning type'' shall be adjusted to ``pointer to function returning type''.
[6.7.6.3 Function declarators (including prototypes)] If the parameter type list terminates with an ellipsis (,...), no information about the number or types of the parameters after the comma is supplied.
[6.7.6.3 Function declarators (including prototypes)] The macros defined in the <stdarg.h> header may be used to access arguments that correspond to the ellipsis in a parameter type list.
[6.7.6.3 Function declarators (including prototypes)] If, in a parameter declaration, an identifier can be treated either as a typedef name or as a parameter name, it shall be taken as a typedef name.
[6.7.6.3 Function declarators (including prototypes)] If the function declarator is not part of a definition of that function, parameters may have incomplete type and may use the [*] notation in their sequences of declarator specifiers to specify variable length array types.
[6.7.6.3 Function declarators (including prototypes)] An identifier list declares only the identifiers of the parameters of the function.
[6.7.6.3 Function declarators (including prototypes)] An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters.
[6.7.6.3 Function declarators (including prototypes)] For two function types to be compatible, both shall specify compatible return types. Moreover, the parameter type lists, if both are present, shall agree in the number of parameters and in use of the ellipsis terminator; corresponding parameters shall have compatible types.
[6.7.6.3 Function declarators (including prototypes)] If one function type has a parameter type list and the other type is specified by a function declarator that is not part of a function definition and that contains an empty identifier list, the parameter list shall not have an ellipsis terminator.
[6.7.6.3 Function declarators (including prototypes)] If one function type has a parameter type list and the other type is specified by a function definition that contains a (possibly empty) identifier list, both shall agree in the number of parameters.
[6.7.6.3 Function declarators (including prototypes)] When determining the compatability of two function types, if both function types are ``old style'', parameter types are not compared.
[6.7.6.3 Function declarators (including prototypes)] If a declaration occurs outside of any function, the identifiers have file scope and external linkage.
[6.7.8 Type definitions] If a typedef name specifies a variably modified type then it shall have block scope.
[6.7.9 Initialization] No initializer shall attempt to provide a value for an object not contained within the entity being initialized.
[6.7.9 Initialization] All the expressions in an initializer for an object that has static or thread storage duration shall be constant expressions or string literals.
[6.7.9 Initialization] If the declaration of an identifier has block scope, and the identifier has external or internal linkage, the declaration shall have no initializer for the identifier.
[6.7.9 Initialization] If a designated initializer has the form [ constant-expression ] then the current object shall have array type and the expression shall be an integer constant expression.
[6.7.9 Initialization] If a designated initializer has the form . identifer then the current object shall have structure or union type and the identifier shall be the name of a member of that type.
[6.7.9 Initialization] If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate.
[6.7.9 Initialization] If an object that has static or thread storage duration is not initialized explicitly, then: if it has pointer type, it is initialized to a null pointer; if it has arithmetic type, it is initialized to zero; if it is an aggregate, every member is initialized according to these rules; if it is a union, the first named member is initialized according to these rules.
[6.7.9 Initialization] The initializer for a scalar shall be a single expression, optionally enclosed in braces.
[6.7.9 Initialization] When no designations are present, subobjects are initialized in order according to the type of the current object: array elements in increasing subscript order, structure members in declaration order, and the first named member of a union. In contrast, a designation causes the following initializer to begin initialization of the subobject described by the designator.
[6.7.9 Initialization] If the initializer list for a subaggregate or contained union does not begin with a left brace, its subobjects are initialized as usual, but the subaggregate or contained union does not become the current object: current objects are associated only with brace-enclosed initializer lists.
[6.7.9 Initialization] The initialization shall occur in initializer list order, each initializer provided for a particular subobject overriding any previously listed initializer for the same subobject; all subobjects that are not initialized explicitly shall be initialized implicitly the same as objects that have static storage duration.
[6.7.9 Initialization] Any initializer for the subobject which is overridden and so not used to initialize that subobject might not be evaluated at all.
[6.7.9 Initialization] If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration.
[6.7.9 Initialization] If an array of unknown size is initialized, its size is determined by the largest indexed element with an explicit initializer.
[6.7.10 Static assertions] If the value of the constant expression of a static assertion compares unequal to 0, the declaration has no effect.
[6.8 Statements and blocks] A statement specifies an action to be performed.
[6.8 Statements and blocks] A block allows a set of declarations and statements to be grouped into one syntactic unit.
[6.8 Statements and blocks] A full expression is an expression that is not part of another expression or of a declarator.
[6.8.1 Labeled statements] A case or default label shall appear only in a switch statement.
[6.8.1 Labeled statements] Label names shall be unique within a function.
[6.8.2 Compound statement] A compound statement is a block.
[6.8.3 Expression and null statements] The expression in an expression statement is evaluated as a void expression for its side effect.
[6.8.3 Expression and null statements] A null statement (consisting of just a semicolon) performs no operations.
[6.8.3 Expression and null statements] If a function call is evaluated as an expression statement for its side effects only, the discarding of its value may be made explicit by converting the expression to a void expression by means of a cast.
[6.8.4 Selection statements] A selection statement selects among a set of statements depending on the value of a controlling expression.
[6.8.4.1 The if statement] The controlling expression of an if statement shall have scalar type.
[6.8.4.1 The if statement] If the first substatement of an if statement is reached via a label, the second substatement is not executed.
[6.8.4.1 The if statement] An else is associated with the lexically nearest preceding if statement that is allowed by the syntax.
[6.8.4.2 The switch statement] The controlling expression of a switch statement shall have integer type.
[6.8.4.2 The switch statement] If a switch statement has an associated case or default label within the scope of an identifier with a variably modified type, the entire switch statement shall be within the scope of that identifier.
[6.8.4.2 The switch statement] The expression of each case label shall be an integer constant expression and no two of the case constant expressions in the same switch statement shall have the same value after conversion.
[6.8.4.2 The switch statement] A switch statement causes control to jump to, into, or past the statement that is the switch body, depending on the value of a controlling expression, and on the presence of a default label and the values of any case labels on or in the switch body.
[6.8.4.2 The switch statement] A case or default label is accessible only within the closest enclosing switch statement.
[6.8.4.2 The switch statement] If a converted value matches that of the promoted controlling expression of a switch statement, control jumps to the statement following the matched case label.
[6.8.4.2 The switch statement] If no converted case constant expression matches and there is no default label, no part of the switch body is executed.
[6.8.5 Iteration statements] An iteration statement causes a statement called the loop body to be executed repeatedly until the controlling expression compares equal to 0.
[6.8.5 Iteration statements] The controlling expression of an iteration statement shall have scalar type.
[6.8.5 Iteration statements] The declaration part of a for statement shall only declare identifiers for objects having storage class auto or register.
[6.8.5 Iteration statements] An omitted optional controlling expression for an iteration statement is replaced by a nonzero constant, which is a constant expression.
[6.8.5.3 The for statement] If clause-1 of a for statement is an expression, it is evaluated as a void expression before the first evaluation of the controlling expression.
[6.8.5.3 The for statement] An omitted expression-2 of a for statement is replaced by a nonzero constant.
[6.8.6.1 The goto statement] The identifier in a goto statement shall name a label located somewhere in the enclosing function.
[6.8.6.1 The goto statement] A goto statement shall not jump from outside the scope of an identifier having a variably modified type to inside the scope of that identifier.
[6.8.6.1 The goto statement] A goto statement is not allowed to jump past any declarations of objects with variably modified types. A jump within the scope, however, is permitted.
[6.8.6.2 The continue statement] A continue statement shall appear only in or as a loop body.
[6.8.6.2 The continue statement] A continue statement causes a jump to the loop-continuation portion of the smallest enclosing iteration statement; that is, to the end of the loop body.
[6.8.6.3 The break statement] A break statement shall appear only in or as a switch body or loop body.
[6.8.6.4 The return statement] A return statement with an expression shall not appear in a function whose return type is void.
[6.8.6.4 The return statement] A return statement without an expression shall only appear in a function whose return type is void.
[6.8.6.4 The return statement] If a return statement with an expression is executed, the value of the expression is returned to the caller as the value of the function call expression.
[6.8.6.4 The return statement] If the expression of the return statement has a type different from the return type of the function in which it appears, the value is converted as if by assignment to an object having the return type of the function.
[6.9 External definitions] The storage-class specifiers auto and register shall not appear in the declaration specifiers in an external declaration.
[6.9 External definitions] There shall be no more than one external definition for each identifier declared with internal linkage in a translation unit.
[6.9 External definitions] If an identifier declared with internal linkage is used in an expression (other than as a part of the operand of a sizeof or _Alignof operator whose result is an integer constant), there shall be exactly one external definition for the identifier in the translation unit.
[6.9 External definitions] An external definition is an external declaration that is also a definition of a function (other than an inline definition) or an object.
[6.9 External definitions] If an identifier declared with external linkage is used in an expression (other than as part of sizeof or _Alignof whose result is an integer constant), somewhere in the entire program there shall be exactly one external definition for the identifier; otherwise, if such an identifier is not used in an expression, there need be no external definition for it.
[6.9.1 Function definitions] The identifier declared in a function definition (which is the name of the function) shall have a function type, as specified by the declarator portion of the function definition.
[6.9.1 Function definitions] The return type of a function shall be void or a complete object type other than array type.
[6.9.1 Function definitions] The storage-class specifier, if any, in the declaration specifiers of a function shall be either extern or static.
[6.9.1 Function definitions] If the declarator of a function includes a parameter type list, the declaration of each parameter shall include an identifier, except for the special case of a parameter list consisting of a single parameter of type void, in which case there shall not be an identifier.
[6.9.1 Function definitions] If the declarator of a function includes a parameter type list, the list also specifies the types of all the parameters; such a declarator also serves as a function prototype for later calls to the same function in the same translation unit.
[6.9.1 Function definitions] If a function declarator includes an identifier list, the types of the parameters shall be declared in a following declaration list.
[6.9.1 Function definitions] If a function that accepts a variable number of arguments is defined without a parameter type list that ends with the ellipsis notation, the behavior is undefined.
[6.9.1 Function definitions] If the } that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined.
[6.9.2 External object definitions] If the declaration of an identifier for an object has file scope and an initializer, the declaration is an external definition for the identifier.
[6.9.2 External object definitions] If a translation unit contains one or more tentative definitions for an identifier, and the translation unit contains no external definition for that identifier, then the behavior is exactly as if the translation unit contains a file scope declaration of that identifier, with the composite type as of the end of the translation unit, with an initializer equal to 0.
[6.9.2 External object definitions] If the declaration of an identifier for an object is a tentative definition and has internal linkage, the declared type shall not be an incomplete type.
[6.9.2 External object definitions] If at the end of the translation unit containing int i[]; at file scope, the array i still has incomplete type, the implicit initializer causes it to have one element, which is set to zero on program startup.
[6.10 Preprocessing directives] A preprocessing directive consists of a sequence of preprocessing tokens that satisfies the following constraints: The first token in the sequence is a # preprocessing token that is either the first character in the source file (optionally after white space containing no new-line characters) or that follows white space containing at least one new-line character.
[6.10 Preprocessing directives] A new-line character ends the preprocessing directive even if it occurs within what would otherwise be an invocation of a function-like macro.
[6.10 Preprocessing directives] The only white-space characters that shall appear between preprocessing tokens within a preprocessing directive (from just after the introducing # preprocessing token through just before the terminating new-line character) are space and horizontal-tab (including spaces that have replaced comments or possibly other white-space characters in translation phase 3).
[6.10 Preprocessing directives] The implementation can process and skip sections of source files conditionally, include other source files, and replace macros. These capabilities are called preprocessing, because conceptually they occur before translation of the resulting translation unit.
[6.10.1 Conditional inclusion] The expression that controls conditional inclusion shall be an integer constant expression except that: identifiers (including those lexically identical to keywords) are interpreted as described below; and it may contain unary operator expressions which evaluate to 1 if the identifier is currently defined as a macro name, 0 if it is not.
[6.10.1 Conditional inclusion] Each preprocessing token that remains (in the list of preprocessing tokens that will become the controlling expression) after all macro replacements have occurred shall be in the lexical form of a token.
[6.10.1 Conditional inclusion] Prior to evaluation, macro invocations in the list of preprocessing tokens that will become the controlling constant expression are replaced (except for those macro names modified by the defined unary operator), just as in normal text.
[6.10.1 Conditional inclusion] If a conditional inclusion's condition evaluates to false (zero), the group that it controls is skipped: directives are processed only through the name that determines the directive in order to keep track of the level of nested conditionals; the rest of the directives' preprocessing tokens are ignored, as are the other preprocessing tokens in the group.
[6.10.1 Conditional inclusion] If none of the conditions evaluates to true, and there is a #else directive, the group controlled by the #else is processed; lacking a #else directive, all the groups until the #endif are skipped.
[6.10.1 Conditional inclusion] As indicated by the syntax, a preprocessing token shall not follow a #else or #endif directive before the terminating new-line character.
[6.10.2 Source file inclusion] A #include directive shall identify a header or source file that can be processed by the implementation.
[6.10.2 Source file inclusion] The method by which a sequence of preprocessing tokens between a < and a > preprocessing token pair or a pair of " characters is combined into a single header name preprocessing token is implementation-defined.
[6.10.3 Macro replacement] An identifier currently defined as an object-like macro shall not be redefined by another #define preprocessing directive unless the second definition is an object-like macro definition and the two replacement lists are identical.
[6.10.3 Macro replacement] Likewise, an identifier currently defined as a function-like macro shall not be redefined by another #define preprocessing directive unless the second definition is a function-like macro definition that has the same number and spelling of parameters, and the two replacement lists are identical.
[6.10.3 Macro replacement] There shall be white-space between the identifier and the replacement list in the definition of an object-like macro.
[6.10.3 Macro replacement] If the identifier-list in the macro definition does not end with an ellipsis, the number of arguments in an invocation of a function-like macro shall equal the number of parameters in the macro definition. Otherwise, there shall be more arguments in the invocation than there are parameters in the macro definition.
[6.10.3 Macro replacement] The identifier __VA_ARGS__ shall occur only in the replacement-list of a function-like macro that uses the ellipsis notation in the parameters.
[6.10.3 Macro replacement] A parameter identifier in a function-like macro shall be uniquely declared within its scope.
[6.10.3 Macro replacement] The identifier immediately following the define is called the macro name.
[6.10.3 Macro replacement] If a # preprocessing token, followed by an identifier, occurs lexically at the point at which a preprocessing directive could begin, the identifier is not subject to macro replacement.
[6.10.3 Macro replacement] A preprocessing directive of the form `# define identifier replacement-list new-line` defines an object-like macro that causes each subsequent instance of the macro name to be replaced by the replacement list of preprocessing tokens that constitute the remainder of the directive.
[6.10.3 Macro replacement] A preprocessing directive of the form `# define identifier lparen identifier-listopt ) replacement-list new-line` defines a function-like macro with parameters, who use is similar syntactically to a function call.
[6.10.3 Macro replacement] If there are sequences of preprocessing tokens within the list of arguments that would otherwise act as preprocessing directives, the behavior is undefined.
[6.10.3 Macro replacement] If there is a ... in the identifier-list in the macro definition, then the trailing arguments, including any separating comma preprocessing tokens, are merged to form a single item: the variable arguments.
[6.10.3.1 Argument substitution] A parameter in the replacement list, unless preceded by a # or ## preprocessing token or followed by a ## preprocessing token (see below), is replaced by the corresponding argument after all macros contained therein have been expanded.
[6.10.3.1 Argument substitution] An identifier __VA_ARGS__ that occurs in the replacement list shall be treated as if it were a parameter, and the variable arguments shall form the preprocessing tokens used to replace it.
[6.10.3.2 The # operator] Each # preprocessing token in the replacement list for a function-like macro shall be followed by a parameter as the next preprocessing token in the replacement list.
[6.10.3.2 The # operator] If, in the replacement list, a parameter is immediately preceded by a # preprocessing token, both are replaced by a single character string literal preprocessing token that contains the spelling of the preprocessing token sequence for the corresponding argument.
[6.10.3.2 The # operator] If the replacement that results from a # stringification is not a valid character string literal, the behavior is undefined.
[6.10.3.3 The ## operator] A ## preprocessing token shall not occur at the beginning or at the end of a replacement list for either form (object-like and function-like) of macro definition.
[6.10.3.3 The ## operator] If, in the replacement list of a function-like macro, a parameter is immediately preceded or followed by a ## preprocessing token, the parameter is replaced by the corresponding argument's preprocessing token sequence.
[6.10.3.3 The ## operator] If, in the replacement list of a function-like macro, an argument consists of no preprocessing tokens, the parameter is replaced by a placemarker preprocessing token.
[6.10.3.3 The ## operator] Placemarker preprocessing tokens do not appear in the syntax because they are temporary entities that exist only within translation phase 4.
[6.10.3.4 Rescanning and further replacement] If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the source file's preprocessing tokens), it is not replaced.
[6.10.3.5 Scope of macro definitions] A macro definition lasts (independent of block structure) until a corresponding #undef directive is encountered or (if none is encountered) until the end of the preprocessing translation unit.
[6.10.4 Line control] The string literal of a #line directive, if present, shall be a character string literal.
[6.10.4 Line control] The digit sequence of a #line directive shall not specify zero, nor a number greater than 2147483647.
[6.10.6 Pragma directive] An implementation is not required to perform macro replacement in pragmas, but it is permitted except for in standard pragmas (where STDC immediately follows pragma).
[6.10.6 Pragma directive] If the result of macro replacement in a non-standard pragma has the same form as a standard pragma, the behavior is implementation-defined; an implementation is permitted to behave as if it were the standard pragma, but is not required to.
[6.10.6 Pragma directive] If the preprocessing token STDC does immediately follow pragma in the directive (prior to any macro replacement), then no macro replacement is performed on the directive.
[6.10.8 Predefined macro names] None of these macro names, nor the identifier defined, shall be the subject of a #define or a #undef preprocessing directive.
[6.10.8 Predefined macro names] Any predefined macro names shall begin with a leading underscore followed by an uppercase letter or a second underscore.
[6.10.8 Predefined macro names] The implementation shall not predefine the macro __cplusplus, nor shall it define it in any standard header.
[6.10.8.1 Mandatory macros] The predefined macro __DATE__ is the date of translation of the preprocessing translation unit. If the date of translation is not available, an implementation-defined valid date shall be supplied.
[6.10.8.1 Mandatory macros] The predefined macro __FILE__ is the presumed name of the current source file (a character string literal).
[6.10.8.1 Mandatory macros] The predefined macro __LINE__ is the presumed line number (within the current source file) of the current source line (an integer constant).
[6.10.8.1 Mandatory macros] The predefined macro __STDC__ is the integer constant 1, intended to indicate a conforming implementation.
[6.10.8.1 Mandatory macros] The predefined macro __STDC_HOSTED__ is the integer constant 1 if the implementation is a hosted implementation or the integer constant 0 if it is not.
[6.10.8.1 Mandatory macros] The predefined macro __STDC_VERSION__ is an integer constant of type long that is increased with each revision of this International Standard.
[6.10.8.1 Mandatory macros] The predefined macro __TIME__ is the time of translation of the preprocessing translation unit. If the time of translation is not available, an implementation-defined valid time shall be supplied.
[6.10.8.2 Environment macros] If __STDC_ISO_10646__ is defined, then every character in the Unicode required set, when stored in an object of type wchar_t, has the same value as the short identifier of that character.
[6.10.8.2 Environment macros] The conditionally predefined macro __STDC_MB_MIGHT_NEQ_WC__ is the integer constant 1 if, in the encoding for wchar_t, a member of the basic character set need not have a code value equal to its value when used as the lone character in an integer character constant.
[6.10.8.2 Environment macros] The conditionally predefined macro __STDC_UTF_16__ is the integer constant 1, intended to indicate that values of type char16_t are UTF-16 encoded. If some other encoding is used, the macro shall not be defined and the actual encoding used is implementation-defined.
[6.10.8.2 Environment macros] The conditionally predefined macro __STDC_UTF_32__ is the integer constant 1, intended to indicate that values of type char32_t are UTF-32 encoded. If some other encoding is used, the macro shall not be defined and the actual encoding used is implementation-defined.
[6.10.8.3 Conditional feature macros] The conditionally predefined macro __STDC_ANALYZABLE__ is the integer constant 1, intended to indicate conformance to the specifications in annex L (Analyzability).
[6.10.8.3 Conditional feature macros] The conditionally predefined macro __STDC_IEC_559__ is the integer constant 1, intended to indicate conformance to the specifications in annex F (IEC 60559 floating-point arithmetic).
[6.10.8.3 Conditional feature macros] The conditionally predefined macro __STDC_IEC_559_COMPLEX__ is the integer constant 1, intended to indicate adherence to the specifications in annex G (IEC 60559 compatible complex arithmetic).
[6.10.8.3 Conditional feature macros] The conditionally predefined macro __STDC_LIB_EXT1__ is the integer constant 201ymmL, intended to indicate support for the extensions defined in annex K (Bounds-checking interfaces).
[6.10.8.3 Conditional feature macros] The conditionally predefined macro __STDC_NO_ATOMICS__ is the integer constant 1, intended to indicate that the implementation does not support atomic types (including the _Atomic type qualifier) and the <stdatomic.h> header.
[6.10.8.3 Conditional feature macros] The conditionally predefined macro __STDC_NO_COMPLEX__ is the integer constant 1, intended to indicate that the implementation does not support complex types or the <complex.h> header.
[6.10.8.3 Conditional feature macros] The conditionally predefined macro __STDC_NO_THREADS__ is the integer constant 1, intended to indicate that the implementation does not support the <threads.h> header.
[6.10.8.3 Conditional feature macros] The conditionally predefined macro __STDC_NO_VLA__ is the integer constant 1, intended to indicate that the implementation does not support variable length arrays or variably modified types.
[7.1.1 Definitions of terms] A string is a contiguous sequence of characters terminated by and including the first null character.
[7.1.1 Definitions of terms] A pointer to a string is a pointer to its initial (lowest addressed) character.
[7.1.1 Definitions of terms] A null wide character is a wide character with code value zero.
[7.1.1 Definitions of terms] A wide string is a contiguous sequence of wide characters terminated by and including the first null wide character.
[7.1.1 Definitions of terms] A pointer to a wide string is a pointer to its initial (lowest addressed) wide character.
[7.1.1 Definitions of terms] A shift sequence is a contiguous sequence of bytes within a multibyte string that (potentially) causes a change in shift state.
[7.1.1 Definitions of terms] A shift sequence shall not have a corresponding wide character; it is instead taken to be an adjunct to an adjacent multibyte character.
[7.1.1 Definitions of terms] For state-dependent encodings, the values for MB_CUR_MAX and MB_LEN_MAX shall be large enough to count all the bytes in any complete multibyte character plus at least one adjacent shift sequence of maximum length.
[7.1.2 Standard headers] A header is not necessarily a source file, nor are the < and > delimited sequences in header names necessarily valid source file names.
[7.1.2 Standard headers] If a file with the same name as one of the above < and > delimited sequences, not provided as part of the implementation, is placed in any of the standard places that are searched for included source files, the behavior is undefined.
[7.1.2 Standard headers] If used, a header shall be included outside of any external declaration or definition, and it shall first be included before the first reference to any of the functions or objects it declares, or to any of the types or macros it defines.
[7.1.2 Standard headers] The program shall not have any macros with names lexically identical to keywords currently defined prior to the inclusion of the header or when any macro defined in the header is expanded.
[7.1.2 Standard headers] Any definition of an object-like macro in a standard header shall expand to code that is fully protected by parentheses where necessary, so that it groups in an arbitrary expression as if it were a single identifier.
[7.1.2 Standard headers] Any declaration of a library function shall have external linkage.
[7.1.3 Reserved identifiers] All identifiers that begin with an underscore and either an uppercase letter or another underscore are always reserved for any use.
[7.1.3 Reserved identifiers] If the program declares or defines an identifier in a context in which it is reserved, or defines a reserved identifier as a macro name, the behavior is undefined.
[7.1.4 Use of library functions] If a function argument is described as being an array, the pointer actually passed to the function shall have a value such that all address computations and accesses to objects (that would be valid if the pointer did point to the first element of such an array) are in fact valid.
[7.1.4 Use of library functions] An implementation shall provide an actual function for each library function, even if it also provides a macro for that function.
[7.1.4 Use of library functions] A library function shall not directly or indirectly access objects accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function's arguments.
[7.1.4 Use of library functions] Implementations may share their own internal objects between threads if the objects are not visible to users and are protected against data races.
[7.1.4 Use of library functions] Unless otherwise specified, library functions shall perform all operations solely within the current thread if those operations have effects that are visible to users.
[7.2 Diagnostics <assert.h>] If NDEBUG is defined as a macro name at the point in the source file where <assert.h> is included, the assert macro is defined simply as #define assert(ignore) ((void)0).
[7.2 Diagnostics <assert.h>] The assert macro shall be implemented as a macro, not as an actual function.
[7.2 Diagnostics <assert.h>] If the assert macro definition is suppressed in order to access an actual function, the behavior is undefined.
[7.2.1.1 The assert macro] When it is executed, if expression is false, the assert macro writes information about the particular call that failed on the standard error stream in an implementation-defined format. It then calls the abort function.
[7.3.2 Conventions] Values of complex arithmetic are not interpreted as degrees, but as radians.
[7.3.4 The CX_LIMITED_RANGE pragma] When outside external declarations, the pragma takes effect from its occurrence until another CX_LIMITED_RANGE pragma is encountered, or until the end of the translation unit.
[7.3.4 The CX_LIMITED_RANGE pragma] When inside a compound statement, the pragma takes effect from its occurrence until another CX_LIMITED_RANGE pragma is encountered (including within a nested compound statement), or until the end of the compound statement; at the end of a compound statement the state for the pragma is restored to its condition just before the compound statement.
[7.3.5.1 The cacos functions] The cacos functions compute the complex arc cosine of z, with branch cuts outside the interval [-1, +1] along the real axis and return the complex arc cosine value, in the range of a strip mathematically unbounded along the imaginary axis and in the interval [0, pi] along the real axis.
[7.3.5.2 The casin functions] The casin functions compute the complex arc sine of z, with branch cuts outside the interval [-1, +1] along the real axis and return the complex arc sine value, in the range of a strip mathematically unbounded along the imaginary axis and in the interval [-pi/2, +pi/2] along the real axis.
[7.3.5.3 The catan functions] The catan functions compute the complex arc tangent of z, with branch cuts outside the interval [-i, +i] along the imaginary axis and return the complex arc tangent value, in the range of a strip mathematically unbounded along the imaginary axis and in the interval [-pi/2, +pi/2] along the real axis.
[7.3.5.4 The ccos functions] The ccos functions compute the complex cosine of z.
[7.3.5.5 The csin functions] The csin functions compute the complex sine of z.
[7.3.5.6 The ctan functions] The ctan functions compute the complex tangent of z.
[7.3.6.1 The cacosh functions] The cacosh functions compute the complex arc hyperbolic cosine of z, with a branch cut at values less than 1 along the real axis and return the complex arc hyperbolic cosine value, in the range of a half-strip of nonnegative values along the real axis and in the interval [-ipi, +ipi] along the imaginary axis.
[7.3.6.2 The casinh functions] The casinh functions compute the complex arc hyperbolic sine of z, with branch cuts outside the interval [-i, +i] along the imaginary axis and return the complex arc hyperbolic sine value, in the range of a strip mathematically unbounded along the real axis and in the interval [-ipi/2, +ipi/2] along the imaginary axis.
[7.3.6.3 The catanh functions] The catanh functions compute the complex arc hyperbolic tangent of z, with branch cuts outside the interval [-1, +1] along the real axis and return the complex arc hyperbolic tangent value, in the range of a strip mathematically unbounded along the real axis and in the interval [-ipi/2, +ipi/2] along the imaginary axis.
[7.3.6.4 The ccosh functions] The ccosh functions compute the complex hyperbolic cosine of z.
[7.3.6.5 The csinh functions] The csinh functions compute the complex hyperbolic sine of z.
[7.3.6.6 The ctanh functions] The ctanh functions compute the complex hyperbolic tangent of z.
[7.3.7.1 The cexp functions] The cexp functions compute the complex base-e exponential of z.
[7.3.7.2 The clog functions] The clog functions compute the complex natural (base-e) logarithm of z, with a branch cut along the negative real axis and return the complex natural logarithm value, in the range of a strip mathematically unbounded along the real axis and in the interval [-ipi, +ipi] along the imaginary axis.
[7.3.8.1 The cabs functions] The cabs functions compute the complex absolute value (also called norm, modulus, or magnitude) of z.
[7.3.8.2 The cpow functions] The cpow functions compute the complex power function xy, with a branch cut for the first parameter along the negative real axis.
[7.3.8.3 The csqrt functions] The csqrt functions compute the complex square root of z, with a branch cut along the negative real axis and return the complex square root value, in the range of the right half-plane (including the imaginary axis).
[7.3.9.1 The carg functions] The carg functions compute the argument (also called phase angle) of z, with a branch cut along the negative real axis and return the value of the argument in the interval [-pi, +pi].
[7.3.9.2 The cimag functions] The cimag functions compute the imaginary part of z.
[7.3.9.4 The conj functions] The conj functions compute the complex conjugate of z, by reversing the sign of its imaginary part.
[7.3.9.5 The cproj functions] The cproj functions compute a projection of z onto the Riemann sphere: z projects to z except that all complex infinities (even those with one infinite part and one NaN part) project to positive infinity on the real axis.
[7.3.9.6 The creal functions] The creal functions compute the real part of z.
[7.4 Character handling <ctype.h>] The header <ctype.h> declares several functions useful for classifying and mapping characters.
[7.4.1.1 The isalnum function] The isalnum function tests for any character for which isalpha or isdigit is true.
[7.4.1.2 The isalpha function] The isalpha function tests for any character for which isupper or islower is true, or any character that is one of a locale-specific set of alphabetic characters for which none of iscntrl, isdigit, ispunct, or isspace is true.
[7.4.1.3 The isblank function] The isblank function tests for any character that is a standard blank character or is one of a locale-specific set of characters for which isspace is true and that is used to separate words within a line of text.
[7.4.1.4 The iscntrl function] The iscntrl function tests for any control character.
[7.4.1.5 The isdigit function] The isdigit function tests for any decimal-digit character.
[7.4.1.6 The isgraph function] The isgraph function tests for any printing character except space (' ').
[7.4.1.7 The islower function] The islower function tests for any character that is a lowercase letter or is one of a locale-specific set of characters for which none of iscntrl, isdigit, ispunct, or isspace is true.
[7.4.1.8 The isprint function] The isprint function tests for any printing character including space (' ').
[7.4.1.9 The ispunct function] The ispunct function tests for any printing character that is one of a locale-specific set of punctuation characters for which neither isspace nor isalnum is true.
[7.4.1.10 The isspace function] The isspace function tests for any character that is a standard white-space character or is one of a locale-specific set of characters for which isalnum is false.
[7.4.1.11 The isupper function] The isupper function tests for any character that is an uppercase letter or is one of a locale-specific set of characters for which none of iscntrl, isdigit, ispunct, or isspace is true.
[7.4.1.12 The isxdigit function] The isxdigit function tests for any hexadecimal-digit character.
[7.4.2.1 The tolower function] The tolower function converts an uppercase letter to a corresponding lowercase letter.
[7.4.2.1 The tolower function] If the argument is a character for which isupper is true and there are one or more corresponding characters, as specified by the current locale, for which islower is true, the tolower function returns one of the corresponding characters (always the same one for any given locale); otherwise, the argument is returned unchanged.
[7.4.2.2 The toupper function] The toupper function converts a lowercase letter to a corresponding uppercase letter.
[7.4.2.2 The toupper function] If the argument is a character for which islower is true and there are one or more corresponding characters, as specified by the current locale, for which isupper is true, the toupper function returns one of the corresponding characters (always the same one for any given locale); otherwise, the argument is returned unchanged.
[7.6 Floating-point environment <fenv.h>] A floating-point status flag is a system variable whose value is set (but never cleared) when a floating-point exception is raised, which occurs as a side effect of exceptional floating-point arithmetic to provide auxiliary information.
[7.6 Floating-point environment <fenv.h>] A floating-point control mode is a system variable whose value may be set by the user to affect the subsequent behavior of floating-point arithmetic. A floating-point status flag is not an object and can be set more than once within an expression.
[7.6.1 The FENV_ACCESS pragma] The pragma shall occur either outside external declarations or preceding all explicit declarations and statements inside a compound statement.
[7.6.1 The FENV_ACCESS pragma] When outside external declarations, the pragma takes effect from its occurrence until another FENV_ACCESS pragma is encountered, or until the end of the translation unit.
[7.6.1 The FENV_ACCESS pragma] When inside a compound statement, the pragma takes effect from its occurrence until another FENV_ACCESS pragma is encountered (including within a nested compound statement), or until the end of the compound statement; at the end of a compound statement the state for the pragma is restored to its condition just before the compound statement.
[7.6.1 The FENV_ACCESS pragma] If part of a program tests floating-point status flags, sets floating-point control modes, or runs under non-default mode settings, but was translated with the state for the FENV_ACCESS pragma ``off'', the behavior is undefined.
[7.6.2 Floating-point exceptions] An implementation may endow floating-point status flags with more information --for example, the address of the code which first raised the floating-point exception; the functions fegetexceptflag and fesetexceptflag deal with the full content of flags.
[7.6.2.1 The feclearexcept function] The feclearexcept function attempts to clear the supported floating-point exceptions represented by its argument.
[7.6.2.2 The fegetexceptflag function] The fegetexceptflag function attempts to store an implementation-defined representation of the states of the floating-point status flags indicated by the argument excepts in the object pointed to by the argument flagp.
[7.6.2.3 The feraiseexcept function] The feraiseexcept function attempts to raise the supported floating-point exceptions represented by its argument.
[7.6.2.4 The fesetexceptflag function] The fesetexceptflag function attempts to set the floating-point status flags indicated by the argument excepts to the states stored in the object pointed to by flagp.
[7.6.2.5 The fetestexcept function] The fetestexcept function determines which of a specified subset of the floating-point exception flags are currently set.
[7.6.3.1 The fegetround function] The fegetround function gets the current rounding direction.
[7.6.3.1 The fegetround function] The fegetround function returns the value of the rounding direction macro representing the current rounding direction or a negative value if there is no such rounding direction macro or the current rounding direction is not determinable.
[7.6.3.2 The fesetround function] The fesetround function establishes the rounding direction represented by its argument round.
[7.6.3.2 The fesetround function] If the argument of fesetround is not equal to the value of a rounding direction macro, the rounding direction is not changed.
[7.6.4.1 The fegetenv function] The fegetenv function attempts to store the current floating-point environment in the object pointed to by envp.
[7.6.4.2 The feholdexcept function] The feholdexcept function saves the current floating-point environment in the object pointed to by envp, clears the floating-point status flags, and then installs a non-stop (continue on floating-point exceptions) mode, if available, for all floating-point exceptions.
[7.6.4.3 The fesetenv function] The fesetenv function attempts to establish the floating-point environment represented by the object pointed to by envp.
[7.6.4.4 The feupdateenv function] The feupdateenv function attempts to save the currently raised floating-point exceptions in its automatic storage, install the floating-point environment represented by the object pointed to by envp, and then raise the saved floating-point exceptions.
[7.8 Format conversion of integer types <inttypes.h>] The header <inttypes.h> includes the header <stdint.h> and extends it with additional facilities provided by the hosted implementation.
[7.8.2.1 The imaxabs function] The imaxabs function computes the absolute value of an integer.
[7.8.2.2 The imaxdiv function] The imaxdiv function computes numer / denom and numer % denom in a single operation.
[7.8.2.2 The imaxdiv function] The imaxdiv function returns a structure of type imaxdiv_t comprising both the quotient and the remainder.
[7.8.2.2 The imaxdiv function] The imaxdiv_t structure shall contain (in either order) the members quot (the quotient) and rem (the remainder), each of which has type intmax_t.
[7.11.1.1 The setlocale function] The setlocale function may be used to change or query the program's entire current locale or portions thereof.
[7.11.1.1 The setlocale function] A null pointer for locale causes the setlocale function to return a pointer to the string associated with the category for the program's current locale; the program's locale is not changed. The implementation shall arrange to encode in a string the various categories due to a heterogeneous locale when category has the value LC_ALL.
[7.11.2.1 The localeconv function] The localeconv function sets the components of an object with type struct lconv with values appropriate for the formatting of numeric quantities (monetary and otherwise) according to the rules of the current locale.
[7.12 Mathematics <math.h>] If FLT_EVAL_METHOD equals 0, float_t and double_t are float and double, respectively; if FLT_EVAL_METHOD equals 1, they are both double; if FLT_EVAL_METHOD equals 2, they are both long double; and for other values of FLT_EVAL_METHOD, they are otherwise implementation-defined.
[7.12 Mathematics <math.h>] If FP_FAST_FMA is defined, it indicates that the fma function generally executes about as fast as, or faster than, a multiply and an add of double operands. The macros FP_FAST_FMAF FP_FAST_FMAL are, respectively, float and long double analogs of FP_FAST_FMA.
[7.12 Mathematics <math.h>] If the expression math_errhandling & MATH_ERREXCEPT can be nonzero, the implementation shall define the macros FE_DIVBYZERO, FE_INVALID, and FE_OVERFLOW in <fenv.h>.
[7.12.1 Treatment of error conditions] Each function in <math.h> shall execute as if it were a single operation without raising SIGFPE and without generating any of the floating-point exceptions ``invalid'', ``divide-by-zero'', or ``overflow'' except to reflect the result of the function.
[7.12.1 Treatment of error conditions] A domain error occurs if an input argument is outside the domain over which the mathematical function is defined.
[7.12.1 Treatment of error conditions] A pole error (also known as a singularity or infinitary) occurs if the mathematical function has an exact infinite result as the finite input argument(s) are approached in the limit (for example, log(0.0)).
[7.12.1 Treatment of error conditions] A range error occurs if the mathematical result of the function cannot be represented in an object of the specified type, due to extreme magnitude.
[7.12.1 Treatment of error conditions] A floating result overflows if the magnitude of the mathematical result is finite but so large that the mathematical result cannot be represented without extraordinary roundoff error in an object of the specified type.
[7.12.1 Treatment of error conditions] A floating result overflows if the magnitude of the mathematical result is finite but so large that the mathematical result cannot be represented without extraordinary roundoff error in an object of the specified type.
[7.12.1 Treatment of error conditions] If a floating result overflows and default rounding is in effect, then the function returns the value of the macro HUGE_VAL, HUGE_VALF, or HUGE_VALL according to the return type, with the same sign as the correct value of the function.
[7.12.1 Treatment of error conditions] If a floating result overflows and if the integer expression math_errhandling & MATH_ERRNO is nonzero, the integer expression errno acquires the value ERANGE.
[7.12.1 Treatment of error conditions] If a floating result overflows and if the integer expression math_errhandling & MATH_ERREXCEPT is nonzero, the ``overflow'' floating-point exception is raised.
[7.12.1 Treatment of error conditions] If a domain, pole, or range error occurs and the integer expression math_errhandling & MATH_ERRNO is zero, then errno shall either be set to the value corresponding to the error or left unmodified.
[7.12.4.1 The acos functions] The acos functions compute the principal value of the arc cosine of x and return arc cosine x in the interval [0,pi] radians.
[7.12.4.2 The asin functions] The asin functions compute the principal value of the arc sine of x and return arc sine x in the interval [-pi/2, +pi/2] radians.
[7.12.4.3 The atan functions] The atan functions compute the principal value of the arc tangent of x and return arc tangent x in the interval [-pi/2, +pi/2] radians.
[7.12.4.4 The atan2 functions] The atan2 functions compute the value of the arc tangent of y/x, using the signs of both arguments to determine the quadrant of the return value and return arc tangent y/x in the interval [-pi, +pi] radians.
[7.12.4.5 The cos functions] The cos functions compute the cosine of x (measured in radians).
[7.12.4.6 The sin functions] The sin functions compute the sine of x (measured in radians).
[7.12.4.7 The tan functions] The tan functions return the tangent of x (measured in radians).
[7.12.5.1 The acosh functions] The acosh functions compute the (nonnegative) arc hyperbolic cosine of x and return a value in the interval [0, +pi].
[7.12.5.2 The asinh functions] The asinh functions compute the arc hyperbolic sine of x.
[7.12.5.3 The atanh functions] The atanh functions compute the arc hyperbolic tangent of x.
[7.12.5.4 The cosh functions] The cosh functions compute the hyperbolic cosine of x.
[7.12.5.5 The sinh functions] The sinh functions compute the hyperbolic sine of x.
[7.12.5.6 The tanh functions] The tanh functions compute the hyperbolic tangent of x.
[7.12.6.1 The exp functions] The exp functions compute the base-e exponential of x.
[7.12.6.2 The exp2 functions] The exp2 functions compute the base-2 exponential of x.
[7.12.6.3 The expm1 functions] The expm1 functions compute the base-e exponential of the argument, minus 1.
[7.12.6.4 The frexp functions] The frexp functions break a floating-point number into a normalized fraction and an integral power of 2.
[7.12.6.5 The ilogb functions] The ilogb functions extract the exponent of x as a signed int value.
[7.12.6.5 The ilogb functions] If the argument of the ilogb functions is zero they compute the value FP_ILOGB0; if infinite they compute the value INT_MAX; if a NaN they compute the value FP_ILOGBNAN; otherwise, they are equivalent to calling the corresponding logb function and casting the returned value to type int.
[7.12.6.5 The ilogb functions] The ilogb functions return the exponent of x as a signed int value.
[7.12.6.6 The ldexp functions] The ldexp functions multiply a floating-point number by an integral power of 2.
[7.12.6.7 The log functions] The log functions compute the base-e (natural) logarithm of x.
[7.12.6.8 The log10 functions] The log10 functions compute the base-10 (common) logarithm of x.
[7.12.6.8 The log10 functions] The log10 functions return log10 x.
[7.12.6.9 The log1p functions] The log1p functions compute the base-e (natural) logarithm of 1 plus the argument.
[7.12.6.10 The log2 functions] The log2 functions compute the base-2 logarithm of x.
[7.12.6.11 The logb functions] The logb functions extract the exponent of x, as a signed integer value in floating-point format.
[7.12.6.12 The modf functions] The modf functions break the argument value into integral and fractional parts, each of which has the same type and sign as the argument.
[7.12.7.1 The cbrt functions] The cbrt functions compute the real cube root of x.
[7.12.7.2 The fabs functions] The fabs functions compute the absolute value of a floating-point number x.
[7.12.7.3 The hypot functions] The hypot functions compute the square root of the sum of the squares of x and y, without undue overflow or underflow.
[7.12.7.4 The pow functions] The pow functions compute x raised to the power y.
[7.12.7.5 The sqrt functions] The sqrt functions compute the nonnegative square root of x.
[7.12.8.1 The erf functions] The erf functions compute the error function of x.
[7.12.8.2 The erfc functions] The erfc functions compute the complementary error function of x.
[7.12.8.3 The lgamma functions] The lgamma functions compute the natural logarithm of the absolute value of gamma of x.
[7.12.8.4 The tgamma functions] The tgamma functions compute the gamma function of x.
[7.12.9.1 The ceil functions] The ceil functions compute the smallest integer value not less than x.
[7.12.9.2 The floor functions] The floor functions compute the largest integer value not greater than x.
[7.12.9.3 The nearbyint functions] The nearbyint functions round their argument to an integer value in floating-point format, using the current rounding direction and without raising the ``inexact'' floating-point exception.
[7.12.9.3 The nearbyint functions] The rint functions round their argument to an integer value in floating-point format, using the current rounding direction and raises the ``inexact'' floating-point exception if the result differs in value from the argument.
[7.12.9.6 The round functions] The round functions round their argument to the nearest integer value in floating-point format, rounding halfway cases away from zero, regardless of the current rounding direction.
[7.12.9.8 The trunc functions] The trunc functions round their argument to the integer value, in floating format, nearest to but no larger in magnitude than the argument.
[7.12.10.1 The fmod functions] The fmod functions compute the floating-point remainder of x/y.
[7.12.10.2 The remainder functions] The remainder functions compute the remainder x REM y required by IEC 60559.
[7.12.11.1 The copysign functions] The copysign functions produce a value with the magnitude of x and the sign of y.
[7.12.11.2 The nan functions] The nan functions return a quiet NaN, if available, with content indicated through its argument. If the implementation does not support quiet NaNs, the functions return zero.
[7.12.11.3 The nextafter functions] The nextafter functions determine the next representable value, in the type of the function, after x in the direction of y, where x and y are first converted to the type of the function.
[7.12.11.4 The nexttoward functions] The nexttoward functions are equivalent to the nextafter functions except that the second parameter has type long double and the functions return y converted to the type of the function if x equals y.
[7.12.12.1 The fdim functions] The fdim functions determine the positive difference between their arguments.
[7.12.12.2 The fmax functions] The fmax functions determine the maximum numeric value of their arguments
[7.12.12.3 The fmin functions] The fmin functions determine the minimum numeric value of their arguments.
[7.12.13.1 The fma functions] The fma functions compute (x * y) + z, rounded as one ternary operation.
[7.13 Nonlocal jumps <setjmp.h>] The header <setjmp.h> defines the macro setjmp, and declares one function and one type, for bypassing the normal function call and return discipline
[7.13 Nonlocal jumps <setjmp.h>] The type declared is jmp_buf which is an array type suitable for holding the information needed to restore a calling setjmp environment.
[7.13.1.1 The setjmp macro] The setjmp macro saves its calling environment in its jmp_buf argument for later use by the longjmp function.
[7.13.2.1 The longjmp function] The longjmp function restores the environment saved by the most recent invocation of the setjmp macro in the same invocation of the program with the corresponding jmp_buf argument.
[7.13.2.1 The longjmp function] If longjmp is called without a prior invocation of the setjmp macro the behavior is undefined.
[7.13.2.1 The longjmp function] The longjmp function that returns control back to the point of the setjmp invocation might cause memory associated with a variable length array object to be squandered.
[7.14 Signal handling <signal.h>] The header <signal.h> declares a type and two functions and defines several macros, for handling various signals (conditions that may be reported during program execution)
[7.14 Signal handling <signal.h>] sig_atomic_t is the (possibly volatile-qualified) integer type of an object that can be accessed as an atomic entity, even in the presence of asynchronous interrupts.
[7.14 Signal handling <signal.h>] The macro is a signal number denoting abnormal termination, such as is initiated by the abort function.
[7.14 Signal handling <signal.h>] The macro SIGFPE is a signal number denoting an erroneous arithmetic operation, such as zero divide or an operation resulting in overflow.
[7.14 Signal handling <signal.h>] The macro SIGILL is a signal number denoting the detection of an invalid function image, such as an invalid instruction.
[7.14 Signal handling <signal.h>] The macro SIGINT is a signal number denoting the receipt of an interactive attention signal.
[7.14 Signal handling <signal.h>] The macro SIGSEGV is a signal number denoting an invalid access to storage.
[7.14 Signal handling <signal.h>] The macro SIGTERM is a signal number denoting a termination request sent to the program.
[7.14 Signal handling <signal.h>] The complete set of signals, their semantics, and their default handling is implementation-defined; all signal numbers shall be positive.
[7.14.1.1 The signal function] If the value of the function passed to signal() is SIG_DFL, default handling for that signal will occur.
[7.14.1.1 The signal function] If the value of the function passed to signal() is SIG_IGN, the signal will be ignored.
[7.14.1.1 The signal function] An invocation of a function because of a signal, or (recursively) of any further functions called by that invocation (other than functions in the standard library), is called a signal handler.
[7.14.1.1 The signal function] If and when a signal handler returns, if the value of sig is SIGFPE, SIGILL, SIGSEGV, or any other implementation-defined value corresponding to a computational exception, the behavior is undefined; otherwise the program will resume execution at the point it was interrupted.
[7.14.1.1 The signal function] If the signal occurs as the result of calling the abort or raise function, the signal handler shall not call the raise function.
[7.14.1.1 The signal function] If any signal is generated by an asynchronous signal handler, the behavior is undefined.
[7.14.1.1 The signal function] The implementation shall behave as if no library function calls the signal function.
[7.14.1.1 The signal function] If the request can be honored, the signal function returns the value of func for the most recent successful call to signal for the specified signal sig.
[7.14.2.1 The raise function] The raise function causes the handler for the signal specified by its argument to be invoked.
[7.14.2.1 The raise function] If a signal handler is called, the raise function shall not return until after the signal handler does.
[7.16 Variable arguments <stdarg.h>] The va_list type is a complete object type suitable for holding information needed by the macros va_start, va_arg, va_end, and va_copy.
[7.16 Variable arguments <stdarg.h>] If access to the varying arguments is desired, the called function shall declare an object having type va_list.
[7.16 Variable arguments <stdarg.h>] A va_list object may be passed as an argument to another function; if that function invokes the va_arg macro with such a va_list object, the value of the object in the calling function is indeterminate and shall be passed to the va_end macro prior to any further reference to it.
[7.16.1 Variable argument list access macros] Each invocation of the va_start and va_copy macros shall be matched by a corresponding invocation of the va_end macro in the same function.
[7.16.1.1 The va_arg macro] The parameter ap shall have been initialized by the va_start or va_copy macro (without an intervening invocation of the va_end macro for the same ap).
[7.16.1.1 The va_arg macro] The parameter type shall be a type name specified such that the type of a pointer to an object that has the specified type can be obtained simply by postfixing a * to type.
[7.16.1.2 The va_copy macro] Neither the va_copy nor va_start macro shall be invoked to reinitialize dest without an intervening invocation of the va_end macro for the same dest.
[7.16.1.3 The va_end macro] If there is no corresponding invocation of the va_start or va_copy macro, or if the va_end macro is not invoked before the return, the behavior is undefined.
[7.16.1.4 The va_start macro] The va_start macro initializes a unique va_list for subsequent use by the va_arg and va_end macros.
[7.16.1.4 The va_start macro] Neither the va_start nor va_copy macro shall be invoked to reinitialize a va_list without an intervening invocation of the va_end macro for the same va_list.
[7.16.1.4 The va_start macro] If the parameter parmN is declared with the register storage class, with a function or array type, or with a type that is not compatible with the type that results after application of the default argument promotions, the behavior is undefined.
[7.17.1 Introduction] The header <stdatomic.h> defines several macros and declares several types and functions for performing atomic operations on data shared between threads.
[7.17.1 Introduction] The type memory_order is an enumerated type whose enumerators identify memory ordering constraints.
[7.17.1 Introduction] The type atomic_flag is a structure type representing a lock-free, primitive atomic flag.
[7.17.2.1 The ATOMIC_VAR_INIT macro] An atomic object with automatic storage duration that is not explicitly initialized using ATOMIC_VAR_INIT is initially in an indeterminate state; however, the default (zero) initialization for objects with static or thread-local storage duration is guaranteed to produce a valid state.
[7.17.3 Order and consistency] Atomic read-modify-write operations shall always read the last value (in the modification order) stored before the write associated with the read-modify-write operation.
[7.17.3 Order and consistency] An atomic store shall only store a value that has been computed from constants and program input values by a finite sequence of program evaluations, such that each evaluation observes the values of variables as computed by the last prior assignment in the sequence.
[7.17.3 Order and consistency] If an evaluation A is included in the sequence, then all evaluations that assign to the same variable and happen before A are also included.
[7.17.4 Fences] A fence with acquire semantics is called an acquire fence; a fence with release semantics is called a release fence.
[7.17.4 Fences] A release fence A synchronizes with an acquire fence B if there exist atomic operations X and Y, both operating on some atomic object M, such that A is sequenced before X, X modifies M, Y is sequenced before B, and Y reads the value written by X or a value written by any side effect in the hypothetical release sequence X would head if it were a release operation.
[7.17.4 Fences] A release fence A synchronizes with an atomic operation B that performs an acquire operation on an atomic object M if there exists an atomic operation X such that A is sequenced before X, X modifies M, and B reads the value written by X or a value written by any side effect in the hypothetical release sequence X would head if it were a release operation.
[7.17.4 Fences] An atomic operation A that is a release operation on an atomic object M synchronizes with an acquire fence B if there exists some atomic operation X on M such that X is sequenced before B and reads the value written by A or a value written by any side effect in the release sequence headed by A.
[7.17.4.2 The atomic_signal_fence function] The atomic_signal_fence function can be used to specify the order in which actions performed by the thread become visible to the signal handler.
[7.17.5 Lock-free property] A value of 0 for the atomic lock-free macros indicates that the integer or address atomic type is never lock-free; a value of 1 indicates that the type is sometimes lock-free; a value of 2 indicates that the type is always lock-free.
[7.17.5.1 The atomic_is_lock_free generic function] The atomic_is_lock_free generic function indicates whether or not the object pointed to by obj is lock-free
[7.17.8 Atomic flag type and operations] The atomic_flag type provides the classic test-and-set functionality. It has two states, set and clear.
[7.17.8 Atomic flag type and operations] Operations on an object of type atomic_flag shall be lock-free and address-free.
[7.17.8 Atomic flag type and operations] An atomic_flag that is not explicitly initialized with ATOMIC_FLAG_INIT is initially in an indeterminate state.
[7.18 Boolean type and values <stdbool.h>] The <stdbool.h> macro bool expands to _Bool; true expands to the integer constant 1; false expands to the integer constant 0.
[7.19 Common definitions <stddef.h>] The type ptrdiff_t is the signed integer type of the result of subtracting two pointers; size_t is the unsigned integer type of the result of the sizeof operator; max_align_t is an object type whose alignment is as great as is supported by the implementation in all contexts.
[7.19 Common definitions <stddef.h> ] The type wchar_t is an integer type whose range of values can represent distinct codes for all members of the largest extended character set specified among the supported locales; the null character shall have the code value zero.
[7.19 Common definitions <stddef.h>] The macro NULL expands to an implementation-defined null pointer constant; and offsetof(type, member-designator) expands to an integer constant expression that has type size_t, the value of which is the offset in bytes, to the structure member (designated by member-designator), from the beginning of its structure (designated by type).
[7.20 Integer types <stdint.h>] The header <stdint.h> declares sets of integer types having specified widths, and defines corresponding sets of macros. It also defines macros that specify limits of integer types corresponding to types defined in other standard headers.
[7.20.3 Limits of other integer types] The macro PTRDIFF_MIN is the minimum limit of ptrdiff_t.
[7.20.3 Limits of other integer types] The macro PTRDIFF_MAX is the maximum limit of ptrdiff_t.
[7.20.3 Limits of other integer types] The macro SIG_ATOMIC_MIN is the minimum limit of sig_atomic_t.
[7.20.3 Limits of other integer types] The macro SIG_ATOMIC_MAX is the maximum limit of sig_atomic_t.
[7.20.3 Limits of other integer types] The macro SIZE_MAX is the maximum limit of size_t.
[7.20.3 Limits of other integer types] The macro WCHAR_MIN is the minimum limit of wchar_t.
[7.20.3 Limits of other integer types] The macro WCHAR_MAX is the maximum limit of wchar_t.
[7.20.3 Limits of other integer types] The macro WINT_MIN is the minimum limit of wint_t.
[7.20.3 Limits of other integer types] The macro WINT_MAX is the maximum limit of wint_t.
[7.20.4.1 Macros for minimum-width integer constants] The macro INTN_C(value) shall expand to an integer constant expression corresponding to the type int_leastN_t.
[7.20.4.1 Macros for minimum-width integer constants] The macro UINTN_C(value) shall expand to an integer constant expression corresponding to the type uint_leastN_t.
[7.21.1 Introduction] The header <stdio.h> defines several macros, and declares three types and many functions for performing input and output.
[7.21.1 Introduction] The type FILE which is an object type capable of recording all the information needed to control a stream.
[7.21.1 Introduction] The macro BUFSIZ expands to an integer constant expression that is the size of the buffer used by the setbuf function;
[7.21.1 Introduction] The macro EOF expands to an integer constant expression, with type int and a negative value, that is returned by several functions to indicate end-of-file, that is, no more input from a stream.
[7.21.1 Introduction] The macro FOPEN_MAX expands to an integer constant expression that is the minimum number of files that the implementation guarantees can be open simultaneously.
[7.21.1 Introduction] The macro FILENAME_MAX expands to an integer constant expression that is the size needed for an array of char large enough to hold the longest file name string that the implementation guarantees can be opened.
[7.21.1 Introduction] The macro L_tmpnam expands to an integer constant expression that is the size needed for an array of char large enough to hold a temporary file name string generated by the tmpnam function.
[7.21.1 Introduction] The macros SEEK_CUR, SEEK_END, and SEEK_SET expand to integer constant expressions with distinct values, suitable for use as the third argument to the fseek function.
[7.21.1 Introduction] The macro TMP_MAX expands to an integer constant expression that is the minimum number of unique file names that can be generated by the tmpnam function.
[7.21.1 Introduction] stderr is an expression of type ``pointer to FILE'' that points to the FILE object associated with the standard error stream.
[7.21.1 Introduction] stdout is an expression of type ``pointer to FILE'' that points to the FILE object associated with the standard output stream.
[7.21.1 Introduction] stdin is an expression of type ``pointer to FILE'' that points to the FILE object associated with the standard input stream.
[7.21.1 Introduction] If the implementation imposes no practical limit on the length of file name strings, the value of FILENAME_MAX should instead be the recommended size of an array intended to hold a file name string.
[7.21.2 Streams] An implementation need not distinguish between text streams and binary streams.
[7.21.2 Streams] A text stream is an ordered sequence of characters composed into lines, each line consisting of zero or more characters plus a terminating new-line character.
[7.21.2 Streams] A binary stream is an ordered sequence of characters that can transparently record internal data.
[7.21.2 Streams] Data read in from a binary stream shall compare equal to the data that were earlier written out to that stream, under the same implementation.
[7.21.2 Streams] Byte input/output functions shall not be applied to a wide-oriented stream and wide character input/output functions shall not be applied to a byte-oriented stream.
[7.21.2 Streams] An implementation shall support text files with lines containing at least 254 characters, including the terminating new-line character.
[7.21.2 Streams] The value of the macro BUFSIZ shall be at least 256.
[7.21.3 Files] A stream is associated with an external file (which may be a physical device) by opening a file, which may involve creating a new file.
[7.21.3 Files] If a file can support positioning requests (such as a disk file, as opposed to a terminal), then a file position indicator associated with the stream is positioned at the start of the file, unless the file is opened with append mode in which case it is implementation-defined whether the file position indicator is initially positioned at the beginning or the end of the file.
[7.21.3 Files] When a stream is unbuffered, characters are intended to appear from the source or at the destination as soon as possible.
[7.21.3 Files] When a stream is fully buffered, characters are intended to be transmitted to or from the host environment as a block when a buffer is filled.
[7.21.3 Files] When a stream is line buffered, characters are intended to be transmitted to or from the host environment as a block when a new-line character is encountered.
[7.21.3 Files] A file may be disassociated from a controlling stream by closing the file.
[7.21.3 Files] If the main function returns to its original caller, or if the exit function is called, all open files are closed (hence all output streams are flushed) before program termination.
[7.21.3 Files] Functions that open nontemporary files require a file name, which is a string.
[7.21.3 Files] The value of FOPEN_MAX shall be at least eight, including the three standard text streams.
[7.21.4.1 The remove function] The remove function causes the file whose name is the string pointed to by filename to be no longer accessible by that name unless it is created anew.
[7.21.4.1 The remove function] If the file is open, the behavior of the remove function is implementation-defined.
[7.21.4.2 The rename function] The rename function causes the file whose name is the string pointed to by its first argument to be henceforth known by the name given by the string pointed to by its second argument.
[7.21.4.2 The rename function] If a file named by the string pointed to by new exists prior to the call to the rename function, the behavior is implementation-defined.
[7.21.4.3 The tmpfile function] The tmpfile function creates a temporary binary file that is different from any other existing file and that will automatically be removed when it is closed or at program termination.
[7.21.4.3 The tmpfile function] If the program terminates abnormally, whether an open temporary file is removed is implementation-defined.
[7.21.4.4 The tmpnam function] The tmpnam function generates a string that is a valid file name and that is not the same as the name of an existing file. The function is potentially capable of generating at least TMP_MAX different strings, but any or all of them may already be in use by existing files and thus not be suitable return values.
[7.21.4.4 The tmpnam function] The tmpnam function generates a different string each time it is called.
[7.21.4.4 The tmpnam function] The value of the macro TMP_MAX shall be at least 25.
[7.21.5.1 The fclose function] A successful call to the fclose function causes the stream pointed to by stream to be flushed and the associated file to be closed.
[7.21.5.1 The fclose function] The fclose function returns zero if the stream was successfully closed, or EOF if any errors were detected.
[7.21.5.2 The fflush function] If stream points to an output stream or an update stream in which the most recent operation was not input, the fflush function causes any unwritten data for that stream to be delivered to the host environment to be written to the file.
[7.21.5.2 The fflush function] If its argument is a null pointer, the fflush function performs the flushing action on all applicable streams.
[7.21.5.3 The fopen function] The fopen function opens the file whose name is the string pointed to by filename, and associates a stream with it.
[7.21.5.3 The fopen function] If fopen's mode string is "r", the file is opened as a text file for reading.
[7.21.5.3 The fopen function] If fopen's mode string is "w", the file is created as a text file for writing and truncated to zero length if it already exists.
[7.21.5.3 The fopen function] If fopen's mode string is "wx", the file is created as a text file for writing or an error is returned if it already exists.
[7.21.5.3 The fopen function] If fopen's mode string is "a", the file is opened for appending; that is, open or create text file for writing at end-of-file.
[7.21.5.3 The fopen function] If fopen's mode string is "rb", the file is opened as binary file for reading
[7.21.5.3 The fopen function] If fopen's mode string is "wb", the file is created as a binary file for writing and truncated to zero length if it already exists.
[7.21.5.3 The fopen function] If fopen's mode string is "wbx", the file is created as a binary file for writing or an error is returned if it already exists.
[7.21.5.3 The fopen function] If fopen's mode string is "ab", the file is opened as a binary file for appending; that is, open or create binary file for writing at end-of-file.
[7.21.5.3 The fopen function] If fopen's mode string is "r+", the file is opened as a text file for updating (reading and writing).
[7.21.5.3 The fopen function] If fopen's mode string is "w+", the file is created as a text file for updating (reading and writing) and truncated to zero length if it already exists.
[7.21.5.3 The fopen function] If fopen's mode string is "w+x", the file is created as a text file for updating (reading and writing) or an error is returned if it already exists.
[7.21.5.3 The fopen function] If fopen's mode string is "a+", the file is opened or created as a text file for updating (reading and writing), writing at end-of-file.
[7.21.5.3 The fopen function] If fopen's mode string is "r+b" or "rb+", the file is opened as a binary file for updating (reading and writing).
[7.21.5.3 The fopen function] If fopen's mode string is "w+b" or "wb+", the file is created as a binary file for updating (reading and writing) and truncated to zero length if it already exists.
[7.21.5.3 The fopen function] If fopen's mode string is "w+bx" or "wb+x", the file is created as a binary file for updating (reading and write) or an error is returned if it already exists.
[7.21.5.3 The fopen function] If fopen's mode string is "a+b" or "ab+", the file is opened or created as a binary file for updating (reading and writing), writing at end-of-file.
[7.21.5.3 The fopen function] When a file is opened with update mode ('+' as the second or third character in the mode argument value), both input and output may be performed on the associated stream.
[7.21.5.3 The fopen function] When a file is opened in update mode, output shall not be directly followed by input without an intervening call to the fflush function or to a file positioning function (fseek, fsetpos, or rewind), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file.
[7.21.5.3 The fopen function] When opened, a stream is fully buffered if and only if it can be determined not to refer to an interactive device.
[7.21.5.4 The freopen function] The freopen function opens the file whose name is the string pointed to by a filename as its first argument and associates its stream to the stream pointed to by its third argument.
[7.21.5.4 The freopen function] If filename is a null pointer, the freopen function attempts to change the mode of the stream to that specified by mode, as if the name of the file currently associated with the stream had been used.
[7.21.5.4 The freopen function] The freopen function first attempts to close any file that is associated with the specified stream.
[7.21.5.6 The setvbuf function] The setvbuf function may be used only after the stream pointed to by stream has been associated with an open file and before any other operation (other than an unsuccessful call to setvbuf) is performed on the stream.
[7.21.5.6 The setvbuf function] If buf is not a null pointer, the array it points to may be used instead of a buffer allocated by the setvbuf function and the argument size specifies the size of the array; otherwise, size may determine the size of a buffer allocated by the setvbuf function.
[7.21.6 Formatted input/output functions] The formatted input/output functions shall behave as if there is a sequence point after the actions associated with each specifier.
[7.21.6.1 The fprintf function] The fprintf function writes output to the stream pointed to by stream, under control of the string pointed to by format that specifies how subsequent arguments are converted for output.
[7.21.6.1 The fprintf function] If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.
[7.21.6.1 The fprintf function] The fprintf function returns when the end of the format string is encountered.
[7.21.6.1 The fprintf function] The format shall be a multibyte character sequence, beginning and ending in its initial shift state.
[7.21.6.1 The fprintf function] The arguments specifying field width, or precision, or both, shall appear (in that order) before the argument (if any) to be converted.
[7.21.6.1 The fprintf function] A negative field width argument is taken as a -flag followed by a positive field width.
[7.21.6.1 The fprintf function] A negative precision argument is taken as if the precision were omitted.
[7.21.6.1 The fprintf function] If the first character of a signed conversion is not a sign, or if a signed conversion results in no characters, a space is prefixed to the result.
[7.21.6.1 The fprintf function] The following fprintf length modifier hh specifies that a following d, i, o, u, x, or X conversion specifier applies to a signed char or unsigned char argument.
[7.21.6.1 The fprintf function] The following fprintf length modifier h specifies that a following d, i, o, u, x, or X conversion specifier applies to a short int or unsigned short int argument.
[7.21.6.1 The fprintf function] The following fprintf length modifier l (ell) specifies that a following d, i, o, u, x, or X conversion specifier applies to a long int or unsigned long int argument
[7.21.6.1 The fprintf function] The following fprintf length modifier ll (ell-ell) specifies that a following d, i, o, u, x, or X conversion specifier applies to a long long int or unsigned long long int argument; or that a following n conversion specifier applies to a pointer to a long long int argument.
[7.21.6.1 The fprintf function] The following fprintf length modifier j specifies that a following d, i, o, u, x, or X conversion specifier applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a pointer to an intmax_t argument.
[7.21.6.1 The fprintf function] The following fprintf length modifier z specifies that a following d, i, o, u, x, or X conversion specifier applies to a size_t or the corresponding signed integer type argument; or that a following n conversion specifier applies to a pointer to a signed integer type corresponding to size_t argument.
[7.21.6.1 The fprintf function] The following fprintf length modifier t specifies that a following d, i, o, u, x, or X conversion specifier applies to a ptrdiff_t or the corresponding unsigned integer type argument; or that a following n conversion specifier applies to a pointer to a ptrdiff_t argument.
[7.21.6.1 The fprintf function] The following fprintf length modifier L specifies that a following a, A, e, E, f, F, g, or G conversion specifier applies to a long double argument.
[7.21.6.1 The fprintf function] A double argument representing an infinity is converted in one of the styles [-]inf or [-]infinity -- which style is implementation-defined.
[7.21.6.1 The fprintf function] A double argument representing a NaN is converted in one of the styles [-]nan or [-]nan(n-char-sequence) -- which style, and the meaning of any n-char-sequence, is implementation-defined.
[7.21.6.2 The fscanf function] The fscanf function reads input from the stream pointed to by stream, under control of the string pointed to by format that specifies the admissible input sequences and how they are to be converted for assignment, using subsequent arguments as pointers to the objects to receive the converted input.
[7.21.6.2 The fscanf function] If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.
[7.21.6.2 The fscanf function] When all directives have been executed, or if a directive fails, the function returns.
[7.21.6.2 The fscanf function] A directive composed of white-space character(s) is executed by reading input up to the first non-white-space character (which remains unread), or until no more characters can be read.
[7.21.6.2 The fscanf function] If the length of the input item is zero, the execution of the directive fails; this condition is a matching failure unless end-of-file, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.
[7.21.6.2 The fscanf function] If the fscanf input item is not a matching sequence, the execution of the directive fails: this condition is a matching failure.
[7.21.6.2 The fscanf function] The fscanf function returns the value of the macro EOF if an input failure occurs before the first conversion (if any) has completed.
[7.21.6.3 The printf function] The printf function is equivalent to fprintf with the argument stdout interposed before the arguments to printf.
[7.21.6.3 The printf function] The printf function returns the number of characters transmitted, or a negative value if an output or encoding error occurred.
[7.21.6.4 The scanf function] The scanf function is equivalent to fscanf with the argument stdin interposed before the arguments to scanf.
[7.21.6.4 The scanf function] The scanf function returns the value of the macro EOF if an input failure occurs before the first conversion (if any) has completed.
[7.21.6.5 The snprintf function] The snprintf function is equivalent to fprintf, except that the output is written into an array rather than to a stream.
[7.21.6.5 The snprintf function] If copying takes place between objects that overlap, the behavior is undefined.
[7.21.6.5 The snprintf function] The snprintf function returns the number of characters that would have been written had n been sufficiently large, not counting the terminating null character, or a negative value if an encoding error occurred.
[7.21.6.6 The sprintf function] The sprintf function is equivalent to fprintf, except that the output is written into an array rather than to a stream.
[7.21.6.6 The sprintf function] A null character is written at the end of the characters written; it is not counted as part of the returned value.
[7.21.6.6 The sprintf function] If copying takes place between objects that overlap, the behavior is undefined.
[7.21.6.6 The sprintf function] The sprintf function returns the number of characters written in the array, not counting the terminating null character, or a negative value if an encoding error occurred.
[7.21.6.7 The sscanf function] The sscanf function is equivalent to fscanf, except that input is obtained from a string rather than from a stream.
[7.21.6.7 The sscanf function] If copying takes place between objects that overlap, the behavior is undefined.
[7.21.6.7 The sscanf function] The sscanf function returns the value of the macro EOF if an input failure occurs before the first conversion (if any) has completed.
[7.21.6.8 The vfprintf function] The vfprintf function is equivalent to fprintf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.21.6.9 The vfscanf function] The vfscanf function is equivalent to fscanf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.21.6.10 The vprintf function] The vprintf function is equivalent to printf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.21.6.11 The vscanf function] The vscanf function is equivalent to scanf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.21.6.12 The vsnprintf function] The vsnprintf function is equivalent to snprintf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.21.6.13 The vsprintf function] The vsprintf function is equivalent to sprintf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.21.6.14 The vsscanf function] The vsscanf function is equivalent to sscanf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.21.7.1 The fgetc function] If the end-of-file indicator for the input stream pointed to by stream is not set and a next character is present, the fgetc function obtains that character as an unsigned char converted to an int and advances the associated file position indicator for the stream (if defined).
[7.21.7.1 The fgetc function] If the end-of-file indicator for the stream is set, or if the stream is at end-of-file, the end-of-file indicator for the stream is set and the fgetc function returns EOF.
[7.21.7.1 The fgetc function] An end-of-file and a read error can be distinguished by use of the feof and ferror functions.
[7.21.7.2 The fgets function] The fgets function reads at most one less than the number of characters specified by n from the stream pointed to by stream into the array pointed to by s.
[7.21.7.2 The fgets function] A null character is written immediately after the last character read into the array.
[7.21.7.2 The fgets function] If end-of-file is encountered by fgets and no characters have been read into the array, the contents of the array remain unchanged and a null pointer is returned.
[7.21.7.2 The fgets function] If a read error occurs during the fgets operation, the array contents are indeterminate and a null pointer is returned.
[7.21.7.3 The fputc function] The fputc function writes the character specified by c (converted to an unsigned char) to the output stream pointed to by stream, at the position indicated by the associated file position indicator for the stream (if defined), and advances the indicator appropriately.
[7.21.7.3 The fputc function] If the file cannot support positioning requests, or if the stream was opened with append mode, the character is appended to the output stream.
[7.21.7.3 The fputc function] The fputc function returns the character written.
[7.21.7.3 The fputc function] If a write error occurs, the error indicator for the stream is set and fputc returns EOF.
[7.21.7.4 The fputs function] The fputs function writes the string pointed to by s to the stream pointed to by stream.
[7.21.7.4 The fputs function] The fputs function returns EOF if a write error occurs; otherwise it returns a nonnegative value.
[7.21.7.5 The getc function] The getc function is equivalent to fgetc, except that if it is implemented as a macro, it may evaluate stream more than once, so the argument should never be an expression with side effects.
[7.21.7.5 The getc function] The getc function returns the next character from the input stream pointed to by stream.
[7.21.7.5 The getc function] If the stream is at end-of-file, the end-of-file indicator for the stream is set and getc returns EOF.
[7.21.7.5 The getc function] If a read error occurs, the error indicator for the stream is set and getc returns EOF.
[7.21.7.6 The getchar function] The getchar function is equivalent to getc with the argument stdin.
[7.21.7.6 The getchar function] The getchar function returns the next character from the input stream pointed to by stdin.
[7.21.7.6 The getchar function] If the stream is at end-of-file, the end-of-file indicator for the stream is set and getchar returns EOF.
[7.21.7.6 The getchar function] If a read error occurs, the error indicator for the stream is set and getchar returns EOF.
[7.21.7.7 The putc function] The putc function is equivalent to fputc, except that if it is implemented as a macro, it may evaluate stream more than once, so that argument should never be an expression with side effects.
[7.21.7.7 The putc function] The putc function returns the character written.
[7.21.7.7 The putc function] If a write error occurs, the error indicator for the stream is set and putc returns EOF.
[7.21.7.8 The putchar function] The putchar function is equivalent to putc with the second argument stdout.
[7.21.7.8 The putchar function] The putchar function returns the character written.
[7.21.7.8 The putchar function] If a write error occurs, the error indicator for the stream is set and putchar returns EOF.
[7.21.7.9 The puts function] The puts function writes the string pointed to by s to the stream pointed to by stdout, and appends a new-line character to the output.
[7.21.7.9 The puts function] The puts function returns EOF if a write error occurs; otherwise it returns a nonnegative value.
[7.21.7.10 The ungetc function] The ungetc function pushes the character specified by c (converted to an unsigned char) back onto the input stream pointed to by stream.
[7.21.7.10 The ungetc function] A successful intervening call (with the stream pointed to by stream) to a file positioning function (fseek, fsetpos, or rewind) discards any pushed-back characters for the stream.
[7.21.7.10 The ungetc function] If the ungetc function is called too many times on the same stream without an intervening read or file positioning operation on that stream, the operation may fail.
[7.21.7.10 The ungetc function] If the value of c equals that of the macro EOF, the operation fails and the input stream is unchanged.
[7.21.7.10 The ungetc function] The value of the file position indicator for the stream after reading or discarding all pushed-back characters shall be the same as it was before the characters were pushed back.
[7.21.7.10 The ungetc function] The ungetc function returns the character pushed back after conversion, or EOF if the operation fails.
[7.21.8.1 The fread function] The fread function reads, into the array pointed to by ptr, up to nmemb elements whose size is specified by size, from the stream pointed to by stream.
[7.21.8.1 The fread function] If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.
[7.21.8.1 The fread function] If a partial element is read, its value is indeterminate.
[7.21.8.1 The fread function] The fread function returns the number of elements successfully read, which may be less than nmemb if a read error or end-of-file is encountered.
[7.21.8.1 The fread function] If size or nmemb is zero, fread returns zero and the contents of the array and the state of the stream remain unchanged.
[7.21.8.2 The fwrite function] The fwrite function writes, from the array pointed to by ptr, up to nmemb elements whose size is specified by size, to the stream pointed to by stream.
[7.21.8.2 The fwrite function] If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.
[7.21.8.2 The fwrite function] The fwrite function returns the number of elements successfully written, which will be less than nmemb only if a write error is encountered.
[7.21.8.2 The fwrite function] If size or nmemb is zero, fwrite returns zero and the state of the stream remains unchanged.
[7.21.9.1 The fgetpos function] The fgetpos function stores the current values of the parse state (if any) and file position indicator for the stream pointed to by stream in the object pointed to by pos.
[7.21.9.1 The fgetpos function] If successful, the fgetpos function returns zero; on failure, the fgetpos function returns nonzero and stores an implementation-defined positive value in errno.
[7.21.9.2 The fseek function] The fseek function sets the file position indicator for the stream pointed to by stream.
[7.21.9.2 The fseek function] If a read or write error occurs, the error indicator for the stream is set and fseek fails.
[7.21.9.2 The fseek function] For a text stream, either offset shall be zero, or offset shall be a value returned by an earlier successful call to the ftell function on a stream associated with the same file and whence shall be SEEK_SET.
[7.21.9.2 The fseek function] The fseek function returns nonzero only for a request that cannot be satisfied.
[7.21.9.3 The fsetpos function] The fsetpos function sets the mbstate_t object (if any) and file position indicator for the stream pointed to by stream according to the value of the object pointed to by pos, which shall be a value obtained from an earlier successful call to the fgetpos function on a stream associated with the same file.
[7.21.9.3 The fsetpos function] If a read or write error occurs, the error indicator for the stream is set and fsetpos fails.
[7.21.9.3 The fsetpos function] A successful call to the fsetpos function undoes any effects of the ungetc function on the stream, clears the end-of-file indicator for the stream, and then establishes the new parse state and position.
[7.21.9.3 The fsetpos function] If successful, the fsetpos function returns zero; on failure, the fsetpos function returns nonzero and stores an implementation-defined positive value in errno.
[7.21.9.4 The ftell function] The ftell function obtains the current value of the file position indicator for the stream pointed to by stream.
[7.21.9.4 The ftell function] If successful, the ftell function returns the current value of the file position indicator for the stream.
[7.21.9.5 The rewind function] The rewind function sets the file position indicator for the stream pointed to by stream to the beginning of the file.
[7.21.9.5 The rewind function] The rewind function returns no value.
[7.21.10.1 The clearerr function] The clearerr function clears the end-of-file and error indicators for the stream pointed to by stream.
[7.21.10.1 The clearerr function] The clearerr function returns no value.
[7.21.10.2 The feof function] The feof function tests the end-of-file indicator for the stream pointed to by stream.
[7.21.10.2 The feof function] The feof function returns nonzero if and only if the end-of-file indicator is set for stream.
[7.21.10.3 The ferror function] The ferror function tests the error indicator for the stream pointed to by stream.
[7.21.10.3 The ferror function] The ferror function returns nonzero if and only if the error indicator is set for stream.
[7.21.10.4 The perror function] The perror function maps the error number in the integer expression errno to an error message.
[7.21.10.4 The perror function] The perror function returns no value.
[7.22 General utilities <stdlib.h>] The macro EXIT_FAILURE expands to a integer constant expressions that can be used as the argument to the exit function to return unsuccessful termination status, respectively, to the host environment;
[7.22 General utilities <stdlib.h>] The macro EXIT_SUCCESS expands to a integer constant expressions that can be used as the argument to the exit function to return successful termination status, respectively, to the host environment;
[7.22 General utilities <stdlib.h>] The RAND_MAX macro expands to an integer constant expression that is the maximum value returned by the rand function.
[7.22 General utilities <stdlib.h>] The MB_CUR_MAX macro expands to a positive integer expression with type size_t that is the maximum number of bytes in a multibyte character for the extended character set specified by the current locale (category LC_CTYPE).
[7.22.1.1 The atof function] The atof function converts the initial portion of the string pointed to by its argument to double representation.
[7.22.1.3 The strtod, strtof, and strtold functions] If the subject sequence begins with a minus sign, the sequence is interpreted as negated. A character sequence INF or INFINITY is interpreted as an infinity, if representable in the return type, else like a floating constant that is too large for the range of the return type.
[7.22.1.4 The strtol, strtoll, strtoul, and strtoull functions] If the subject sequence is empty or does not have the expected form, no conversion is performed; the value of nptr is stored in the object pointed to by endptr, provided that endptr is not a null pointer.
[7.22.1.4 The strtol, strtoll, strtoul, and strtoull functions] If the correct value is outside the range of representable values, LONG_MIN, LONG_MAX, LLONG_MIN, LLONG_MAX, ULONG_MAX, or ULLONG_MAX is returned (according to the return type and sign of the value, if any), and the value of the macro ERANGE is stored in errno.
[7.22.2.1 The rand function] The rand function computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
[7.22.2.1 The rand function] There are no guarantees as to the quality of the random sequence produced and some implementations are known to produce sequences with distressingly non-random low-order bits. Applications with particular requirements should use a generator that is known to be sufficient for their needs.
[7.22.2.1 The rand function] The rand function is not required to avoid data races with other calls to pseudo-random sequence generation functions.
[7.22.2.1 The rand function] The value of the RAND_MAX macro shall be at least 32767.
[7.22.2.2 The srand function] The srand function uses the argument as a seed for a new sequence of pseudo-random numbers to be returned by subsequent calls to rand.
[7.22.2.2 The srand function] If srand is then called with the same seed value, the sequence of pseudo-random numbers shall be repeated.
[7.22.2.2 The srand function] If rand is called before any calls to srand have been made, the same sequence shall be generated as when srand is first called with a seed value of 1.
[7.22.2.2 The srand function] The srand function is not required to avoid data races with other calls to pseudo-random sequence generation functions.
[7.22.3 Memory management functions] Each such allocation shall yield a pointer to an object disjoint from any other object.
[7.22.3 Memory management functions] If the space cannot be allocated, a null pointer is returned.
[7.22.3 Memory management functions] If the size of the space requested is zero, the behavior is implementation-defined: either a null pointer is returned, or the behavior is as if the size were some nonzero value, except that the returned pointer shall not be used to access an object.
[7.22.3.1 The aligned_alloc function] The aligned_alloc function allocates space for an object whose alignment is specified by alignment, whose size is specified by size, and whose value is indeterminate.
[7.22.3.1 The aligned_alloc function] The value of alignment shall be a valid alignment supported by the implementation and the value of size shall be an integral multiple of alignment.
[7.22.3.2 The calloc function] The calloc function allocates space for an array of nmemb objects, each of whose size is specified by the size argument.
[7.22.3.3 The free function] The free function causes the space pointed to by the ptr argument to be deallocated, that is, made available for further allocation.
[7.22.3.3 The free function] If the ptr argument of the free function is a null pointer, no action occurs.
[7.22.3.4 The malloc function] The malloc function allocates space for an object whose size is specified by the size argument and whose value is indeterminate.
[7.22.3.5 The realloc function] The realloc function deallocates the old object pointed to by the ptr argument and returns a pointer to a new object that has the size specified by the size argument.
[7.22.3.5 The realloc function] The contents of the new object shall be the same as that of the old object prior to deallocation, up to the lesser of the new and old sizes.
[7.22.3.5 The realloc function] If the ptr argument is a null pointer, the realloc function behaves like the malloc function for the specified size.
[7.22.3.5 The realloc function] If memory for the new object cannot be allocated, the old object is not deallocated and its value is unchanged.
[7.22.4.1 The abort function] The abort function causes abnormal program termination to occur, unless the signal SIGABRT is being caught and the signal handler does not return.
[7.22.4.1 The abort function] An implementation-defined form of the status unsuccessful termination is returned to the host environment by means of the function call raise(SIGABRT).
[7.22.4.1 The abort function] The abort function does not return to its caller.
[7.22.4.2 The atexit function] The atexit function registers the function pointed to by func, to be called without arguments at normal program termination. It is unspecified whether a call to the atexit function that does not happen before the exit function is called will succeed.
[7.22.4.2 The atexit function] The atexit function registrations are distinct from the at_quick_exit registrations, so applications may need to call both registration functions with the same argument.
[7.22.4.2 The atexit function] The implementation shall support the atexit registration of at least 32 functions.
[7.22.4.3 The at_quick_exit function] The at_quick_exit function registers the function pointed to by func, to be called without arguments should quick_exit be called. It is unspecified whether a call to the at_quick_exit function that does not happen before the quick_exit function is called will succeed.
[7.22.4.3 The at_quick_exit function] The at_quick_exit function registrations are distinct from the atexit registrations, so applications may need to call both registration functions with the same argument.
[7.22.4.3 The at_quick_exit function] The implementation shall support the at_quick_exit registration of at least 32 functions.
[7.22.4.4 The exit function] The exit function causes normal program termination to occur.
[7.22.4.4 The exit function] No functions registered by the at_quick_exit function are called if exit is called.
[7.22.4.4 The exit function] If a program calls the exit function more than once, or calls the quick_exit function in addition to the exit function, the behavior is undefined.
[7.22.4.4 The exit function] First, all functions registered by the atexit function are called, in the reverse order of their registration, except that a function is called after any previously registered functions that had already been called at the time it was registered.
[7.22.4.4 The exit function] If, during the call to any function registered by atexit, a call to the longjmp function is made that would terminate the call to the registered function, the behavior is undefined.
[7.22.4.4 The exit function] Each function registered by atexit is called as many times as it was registered, and in the correct order with respect to other registered functions.
[7.22.4.4 The exit function] If the value of the argument to the exit function is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned.
[7.22.4.4 The exit function] If the value of the argument to the exit function is EXIT_FAILURE, an implementation-defined form of the status unsuccessful termination is returned.
[7.22.4.5 The _Exit function] The _Exit function causes normal program termination to occur and control to be returned to the host environment. No functions registered by the atexit function, the at_quick_exit function, or signal handlers registered by the signal function are called.
[7.22.4.6 The getenv function] The getenv function searches an environment list, provided by the host environment, for a string that matches the string pointed to by name.
[7.22.4.6 The getenv function] The getenv function need not avoid data races with other threads of execution that modify the environment list.
[7.22.4.6 The getenv function] The getenv function returns a pointer to a string associated with the matched list member. The string pointed to shall not be modified by the program, but may be overwritten by a subsequent call to the getenv function.
[7.22.4.7 The quick_exit function] The quick_exit function causes normal program termination to occur. No functions registered by the atexit function or signal handlers registered by the signal function are called.
[7.22.4.7 The quick_exit function] If a program calls the quick_exit function more than once, or calls the exit function in addition to the quick_exit function, the behavior is undefined.
[7.22.4.7 The quick_exit function] If a signal is raised while the quick_exit function is executing, the behavior is undefined.
[7.22.4.7 The quick_exit function] The quick_exit function first calls all functions registered by the at_quick_exit function, in the reverse order of their registration, except that a function is called after any previously registered functions that had already been called at the time it was registered.
[7.22.4.7 The quick_exit function] If, during the call to any functions registered by at_quick_exit, a call to the longjmp function is made that would terminate the call to the registered function, the behavior is undefined.
[7.22.4.7 The quick_exit function] Each function registered by at_quick_exit is called as many times as it was registered, and in the correct order with respect to other registered functions.
[7.22.4.8 The system function] If the argument of the system function is a null pointer, the system function determines whether the host environment has a command processor and returns nonzero if so.
[7.22.4.8 The system function] If the argument is not a null pointer, the system function passes the string pointed to by its argument to the host environment's command processor to be executed in a manner which the implementation shall document; this might then cause the program calling system to behave in a non-conforming manner or to terminate.
[7.22.4.8 The system function] If the argument is a null pointer, the system function returns nonzero only if a command processor is available. If the argument is not a null pointer, and the system function does return, it returns an implementation-defined value.
[7.22.5 Searching and sorting utilities] A sequence point occurs immediately before and immediately after each call to the comparison function, and also between any call to the comparison function and any movement of the objects passed as arguments to that call.
[7.22.5.1 The bsearch function] The bsearch function searches an array of nmemb objects, the initial element of which is pointed to by base, for an element that matches the object pointed to by key.
[7.22.5.1 The bsearch function] The comparison function pointed to by compar is called with two arguments that point to the key object and to an array element, in that order.
[7.22.5.1 The bsearch function] The function shall return an integer less than, equal to, or greater than zero if the key object is considered, respectively, to be less than, to match, or to be greater than the array element.
[7.22.5.1 The bsearch function] The array shall consist of: all the elements that compare less than, all the elements that compare equal to, and all the elements that compare greater than the key object, in that order.
[7.22.5.1 The bsearch function] The bsearch function returns a pointer to a matching element of the array, or a null pointer if no match is found. If two elements compare as equal, which element is matched is unspecified.
[7.22.5.2 The qsort function] The qsort function sorts an array of nmemb objects, the initial element of which is pointed to by base. The contents of the array are sorted into ascending order according to a comparison function pointed to by compar, which is called with two arguments that point to the objects being compared.
[7.22.5.2 The qsort function] The qsort function shall return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second. If two elements compare as equal, their order in the resulting sorted array is unspecified.
[7.22.7 Multibyte/wide character conversion functions] If the locale employs special bytes to change the shift state, these bytes do not produce separate wide character codes, but are grouped with an adjacent multibyte character.
[7.22.7.1 The mblen function] The mblen function determines the number of bytes contained in the multibyte character.
[7.22.7.2 The mbtowc function] The mbtowc function converts a multibyte character into a wide character.
[7.22.7.3 The wctomb function] The wctomb function converts a wide character into a multibyte character.
[7.22.8.1 The mbstowcs function] The mbstowcs function converts a sequence of multibyte characters that begins in the initial shift state from the array pointed to by its argument into a sequence of corresponding wide characters.
[7.22.8.1 The mbstowcs function] If copying takes place between objects that overlap, the behavior is undefined.
[7.22.8.1 The mbstowcs function] If an invalid multibyte character is encountered, the mbstowcs function returns (size_t)(-1).
[7.22.8.2 The wcstombs function] The wcstombs function converts a sequence of wide characters from the array pointed to by its argument into a sequence of corresponding multibyte characters that begins in the initial shift state.
[7.22.8.2 The wcstombs function] If copying takes place between objects that overlap, the behavior is undefined.
[7.22.8.2 The wcstombs function] If a wide character is encountered that does not correspond to a valid multibyte character, the wcstombs function returns (size_t)(-1).
[7.23 _Noreturn <stdnoreturn.h>] The header <stdnoreturn.h> defines the macro noreturn which expands to _Noreturn.
[7.24.1 String function conventions] If an array is accessed beyond the end of an object, the behavior is undefined.
[7.24.2.1 The memcpy function] The memcpy function copies n characters from the object pointed to by s2 into the object pointed to by s1, including any null characters.
[7.24.2.1 The memcpy function] If copying takes place between objects that overlap, the behavior is undefined.
[7.24.2.2 The memmove function] The memmove function copies n characters from the object pointed to by s2 into the object pointed to by s1. Copying takes place as if the n characters from the object pointed to by s2 are first copied into a temporary array of n characters that does not overlap the objects pointed to by s1 and s2.
[7.24.2.3 The strcpy function] The strcpy function copies the string pointed to by s2 (including the terminating null character) into the array pointed to by s1.
[7.24.2.3 The strcpy function] If copying takes place between objects that overlap, the behavior is undefined.
[7.24.2.4 The strncpy function] The strncpy function copies not more than n characters (characters that follow a null character are not copied) from the array pointed to by s2 to the array pointed to by s1.
[7.24.2.4 The strncpy function] If the array pointed to by s2 is a string that is shorter than n characters, null characters are appended to the copy in the array pointed to by s1, until n characters in all have been written.
[7.24.3.1 The strcat function] The strcat function appends a copy of the string pointed to by s2 (including the terminating null character) to the end of the string pointed to by s1.
[7.24.3.1 The strcat function] If copying takes place between objects that overlap, the behavior is undefined.
[7.24.3.2 The strncat function] The strncat function appends not more than n characters (a null character and characters that follow it are not appended) from the array pointed to by s2 to the end of the string pointed to by s1. A terminating null character is always appended to the result.
[7.24.4.1 The memcmp function] The memcmp function compares the first n characters of the object pointed to by s1 to the first n characters of the object pointed to by s2, and does not stop comparing if a null character is encountered.
[7.24.4.1 The memcmp function] The memcmp function returns an integer greater than, equal to, or less than zero, accordingly as the object pointed to by s1 is greater than, equal to, or less than the object pointed to by s2.
[7.24.4.2 The strcmp function] The strcmp function compares the string pointed to by s1 to the string pointed to by s2.
[7.24.4.2 The strcmp function] The strcmp function returns an integer greater than, equal to, or less than zero, accordingly as the string pointed to by s1 is greater than, equal to, or less than the string pointed to by s2.
[7.24.4.3 The strcoll function] The strcoll function compares the string pointed to by s1 to the string pointed to by s2, both interpreted as appropriate to the LC_COLLATE category of the current locale.
[7.24.4.3 The strcoll function] The strcoll function returns an integer greater than, equal to, or less than zero, accordingly as the string pointed to by s1 is greater than, equal to, or less than the string pointed to by s2 when both are interpreted as appropriate to the current locale.
[7.24.4.4 The strncmp function] The strncmp function compares not more than n characters (characters that follow a null character are not compared) from the array pointed to by s1 to the array pointed to by s2.
[7.24.4.4 The strncmp function] The strncmp function returns an integer greater than, equal to, or less than zero, accordingly as the possibly null-terminated array pointed to by s1 is greater than, equal to, or less than the possibly null-terminated array pointed to by s2.
[7.24.4.5 The strxfrm function] The strxfrm function transforms the string pointed to by s2 and places the resulting string into the array pointed to by s1.
[7.24.4.5 The strxfrm function] If copying takes place between objects that overlap, the behavior is undefined.
[7.24.4.5 The strxfrm function] The strxfrm function returns the length of the transformed string (not including the terminating null character).
[7.24.4.5 The strxfrm function] If the value returned is n or more, the contents of the array pointed to by s1 are indeterminate.
[7.24.5.1 The memchr function] The memchr function locates the first occurrence of c (converted to an unsigned char) in the initial n characters (each interpreted as unsigned char) of the object pointed to by s, and does not stop searching if a null character is encountered.
[7.24.5.1 The memchr function] The implementation shall behave as if it reads the characters sequentially and stops as soon as a matching character is found.
[7.24.5.1 The memchr function] The memchr function returns a pointer to the located character, or a null pointer if the character does not occur in the object.
[7.24.5.2 The strchr function] The strchr function locates the first occurrence of c (converted to a char) in the string pointed to by s.
[7.24.5.3 The strcspn function] The strcspn function computes the length of the maximum initial segment of the string pointed to by s1 which consists entirely of characters not from the string pointed to by s2.
[7.24.5.4 The strpbrk function] The strpbrk function locates the first occurrence in the string pointed to by s1 of any character from the string pointed to by s2.
[7.24.5.5 The strrchr function] The strrchr function locates the last occurrence of c (converted to a char) in the string pointed to by s.
[7.24.5.5 The strrchr function] The strrchr function returns a pointer to the character, or a null pointer if c does not occur in the string.
[7.24.5.6 The strspn function] The strspn function computes the length of the maximum initial segment of the string pointed to by s1 which consists entirely of characters from the string pointed to by s2.
[7.24.5.7 The strstr function] The strstr function locates the first occurrence in the string pointed to by s1 of the sequence of characters (excluding the terminating null character) in the string pointed to by s2.
[7.24.5.7 The strstr function] The strstr function returns a pointer to the located string, or a null pointer if the string is not found.
[7.24.5.8 The strtok function] A sequence of calls to the strtok function breaks the string pointed to by s1 into a sequence of tokens, each of which is delimited by a character from the string pointed to by s2.
[7.24.5.8 The strtok function] If strtok finds a token, the trailing delimiter character is overwritten by a null character, which terminates the current token. The function then saves a pointer to the following character, from which the next search for a token will start.
[7.24.5.8 The strtok function] The strtok function is not required to avoid data races with other calls to the strtok function. The strtok_s function can be used instead to avoid data races.
[7.24.6.1 The memset function] The memset function copies the value of c (converted to an unsigned char) into each of the first n characters of the object pointed to by s.
[7.24.6.2 The strerror function] The strerror function maps the number in errnum to a message string.
[7.24.6.2 The strerror function] Typically, the values for errnum come from errno, but strerror shall map any value of type int to a message.
[7.24.6.2 The strerror function] The strerror function is not required to avoid data races with other calls to the strerror function. The strerror_s function can be used instead to avoid data races.
[7.24.6.2 The strerror function] The array pointed to by the result of the strerror function shall not be modified by the program, but may be overwritten by a subsequent call to the strerror function.
[7.24.6.3 The strlen function] The strlen function computes the length of the string pointed to by its argument.
[7.25 Type-generic math <tgmath.h>] If the type of the argument is not compatible with the type of the parameter for the selected function, the behavior is undefined.
[7.25 Type-generic math <tgmath.h>] If at least one argument for a generic parameter is complex, then use of the macro invokes a complex function; otherwise, use of the macro invokes a real function.
[7.25 Type-generic math <tgmath.h>] If all arguments for generic parameters are real, then use of the macro invokes a real function; otherwise, use of the macro results in undefined behavior.
[7.26.1 Introduction] The macro TSS_DTOR_ITERATIONS expands to an integer constant expression representing the maximum number of times that destructors will be called when a thread terminates.
[7.26.1 Introduction] The type cnd_t is a complete object type that holds an identifier for a condition variable.
[7.26.1 Introduction] The type thrd_t is a complete object type that holds an identifier for a thread.
[7.26.1 Introduction] The type tss_t is a complete object type that holds an identifier for a thread-specific storage pointer.
[7.26.1 Introduction] The type mtx_t is a complete object type that holds an identifier for a mutex.
[7.26.1 Introduction] The type tss_dtor_t is the function pointer type void (*)(void*), used for a destructor for a thread-specific storage pointer.
[7.26.1 Introduction] The type thrd_start_t is the function pointer type int (*)(void*) that is passed to thrd_create to create a new thread.
[7.26.1 Introduction] The type once_flag is a complete object type that holds a flag for use by call_once.
[7.26.1 Introduction] The enumeration constant mtx_plain is passed to mtx_init to create a mutex object that supports neither timeout nor test and return.
[7.26.1 Introduction] The enumeration constant mtx_recursive is passed to mtx_init to create a mutex object that supports recursive locking.
[7.26.1 Introduction] The enumeration constant mtx_timed is passed to mtx_init to create a mutex object that supports timeout.
[7.26.1 Introduction] The enumeration constant thrd_timedout is returned by a timed wait function to indicate that the time specified in the call was reached without acquiring the requested resource.
[7.26.1 Introduction] The enumeration constant thrd_success is returned by a function to indicate that the requested operation succeeded.
[7.26.1 Introduction] The enumeration constant thrd_busy is returned by a function to indicate that the requested operation failed because a resource requested by a test and return function is already in use.
[7.26.1 Introduction] The enumeration constant thrd_error is returned by a function to indicate that the requested operation failed.
[7.26.1 Introduction] The enumeration constant thrd_nomem is returned by a function to indicate that the requested operation failed because it was unable to allocate memory.
[7.26.2.1 The call_once function] The call_once function uses the once_flag pointed to by flag to ensure that func is called exactly once, the first time the call_once function is called with that value of flag.
[7.26.2.1 The call_once function] The call_once function returns no value.
[7.26.3.1 The cnd_broadcast function] The cnd_broadcast function unblocks all of the threads that are blocked on the condition variable pointed to by cond at the time of the call.
[7.26.3.1 The cnd_broadcast function] If no threads are blocked on the condition variable pointed to by cond at the time of the call, the function does nothing.
[7.26.3.1 The cnd_broadcast function] The cnd_broadcast function returns thrd_success on success, or thrd_error if the request could not be honored.
[7.26.3.2 The cnd_destroy function] The cnd_destroy function releases all resources used by the condition variable pointed to by cond.
[7.26.3.2 The cnd_destroy function] The cnd_destroy function requires that no threads be blocked waiting for the condition variable pointed to by cond.
[7.26.3.2 The cnd_destroy function] The cnd_destroy function returns no value.
[7.26.3.3 The cnd_init function] The cnd_init function creates a condition variable.
[7.26.3.3 The cnd_init function] If it succeeds it sets the variable pointed to by cond to a value that uniquely identifies the newly created condition variable.
[7.26.3.3 The cnd_init function] The cnd_init function returns thrd_success on success, or thrd_nomem if no memory could be allocated for the newly created condition, or thrd_error if the request could not be honored.
[7.26.3.4 The cnd_signal function] The cnd_signal function unblocks one of the threads that are blocked on the condition variable pointed to by cond at the time of the call.
[7.26.3.4 The cnd_signal function] If no threads are blocked on the condition variable at the time of the call, the function does nothing and return success.
[7.26.3.4 The cnd_signal function] The cnd_signal function returns thrd_success on success or thrd_error if the request could not be honored.
[7.26.3.5 The cnd_timedwait function] The cnd_timedwait function atomically unlocks the mutex pointed to by mtx and endeavors to block until the condition variable pointed to by cond is signaled by a call to cnd_signal or to cnd_broadcast, or until after the TIME_UTC-based calendar time pointed to by ts.
[7.26.3.5 The cnd_timedwait function] When the calling thread becomes unblocked it locks the variable pointed to by mtx before it returns.
[7.26.3.5 The cnd_timedwait function] The cnd_timedwait function requires that the mutex pointed to by mtx be locked by the calling thread.
[7.26.3.5 The cnd_timedwait function] The cnd_timedwait function returns thrd_success upon success, or thrd_timedout if the time specified in the call was reached without acquiring the requested resource, or thrd_error if the request could not be honored.
[7.26.3.6 The cnd_wait function] The cnd_wait function atomically unlocks the mutex pointed to by mtx and endeavors to block until the condition variable pointed to by cond is signaled by a call to cnd_signal or to cnd_broadcast.
[7.26.3.6 The cnd_wait function] When the calling thread becomes unblocked it locks the mutex pointed to by mtx before it returns.
[7.26.3.6 The cnd_wait function] The cnd_wait function requires that the mutex pointed to by mtx be locked by the calling thread.
[7.26.3.6 The cnd_wait function] The cnd_wait function returns thrd_success on success or thrd_error if the request could not be honored.
[7.26.4.1 The mtx_destroy function] The mtx_destroy function releases any resources used by the mutex pointed to by mtx.
[7.26.4.1 The mtx_destroy function] The mtx_destroy function returns no value.
[7.26.4.2 The mtx_init function] The mtx_init function creates a mutex object with properties indicated by type, which must have one of the six values: mtx_plain for a simple non-recursive mutex, mtx_timed for a non-recursive mutex that supports timeout, mtx_plain | mtx_recursive for a simple recursive mutex, or mtx_timed | mtx_recursive for a recursive mutex that supports timeout.
[7.26.4.2 The mtx_init function] If the mtx_init function succeeds, it sets the mutex pointed to by mtx to a value that uniquely identifies the newly created mutex.
[7.26.4.2 The mtx_init function] The mtx_init function returns thrd_success on success, or thrd_error if the request could not be honored.
[7.26.4.3 The mtx_lock function] The mtx_lock function blocks until it locks the mutex pointed to by mtx.
[7.26.4.3 The mtx_lock function] If the mutex is non-recursive, it shall not be locked by the calling thread.
[7.26.4.3 The mtx_lock function] Prior calls to mtx_unlock on the same mutex shall synchronize with this operation.
[7.26.4.3 The mtx_lock function] The mtx_lock function returns thrd_success on success, or thrd_error if the request could not be honored.
[7.26.4.4 The mtx_timedlock function] The mtx_timedlock function endeavors to block until it locks the mutex pointed to by mtx or until after the TIME_UTC-based calendar time pointed to by ts.
[7.26.4.4 The mtx_timedlock function] The specified mutex shall support timeout.
[7.26.4.4 The mtx_timedlock function] If the operation succeeds, prior calls to mtx_unlock on the same mutex shall synchronize with this operation.
[7.26.4.4 The mtx_timedlock function] The mtx_timedlock function returns thrd_success on success, or thrd_timedout if the time specified was reached without acquiring the requested resource, or thrd_error if the request could not be honored.
[7.26.4.5 The mtx_trylock function] The mtx_trylock function endeavors to lock the mutex pointed to by mtx.
[7.26.4.5 The mtx_trylock function] If the mutex is already locked, the function returns without blocking.
[7.26.4.5 The mtx_trylock function] If the operation succeeds, prior calls to mtx_unlock on the same mutex shall synchronize with this operation.
[7.26.4.5 The mtx_trylock function] The mtx_trylock function returns thrd_success on success, or thrd_busy if the resource requested is already in use, or thrd_error if the request could not be honored.
[7.26.4.6 The mtx_unlock function] The mtx_unlock function unlocks the mutex pointed to by mtx.
[7.26.4.6 The mtx_unlock function] The mutex pointed to by mtx shall be locked by the calling thread.
[7.26.4.6 The mtx_unlock function] The mtx_unlock function returns thrd_success on success or thrd_error if the request could not be honored.
[7.26.5.1 The thrd_create function] The thrd_create function creates a new thread executing func(arg).
[7.26.5.1 The thrd_create function] If the thrd_create function succeeds, it sets the object pointed to by thr to the identifier of the newly created thread.
[7.26.5.1 The thrd_create function] The thrd_create function returns thrd_success on success, or thrd_nomem if no memory could be allocated for the thread requested, or thrd_error if the request could not be honored.
[7.26.5.2 The thrd_current function] The thrd_current function identifies the thread that called it.
[7.26.5.2 The thrd_current function] The thrd_current function returns the identifier of the thread that called it.
[7.26.5.3 The thrd_detach function] The thrd_detach function tells the operating system to dispose of any resources allocated to the thread identified by thr when that thread terminates.
[7.26.5.3 The thrd_detach function] The thread identified by thr shall not have been previously detached or joined with another thread.
[7.26.5.3 The thrd_detach function] The thrd_detach function returns thrd_success on success or thrd_error if the request could not be honored.
[7.26.5.4 The thrd_equal function] The thrd_equal function will determine whether the thread identified by thr0 refers to the thread identified by thr1.
[7.26.5.4 The thrd_equal function] The thrd_equal function returns zero if the thread thr0 and the thread thr1 refer to different threads.
[7.26.5.5 The thrd_exit function] The thrd_exit function terminates execution of the calling thread and sets its result code to res.
[7.26.5.5 The thrd_exit function] The program shall terminate normally after the last thread has been terminated.
[7.26.5.5 The thrd_exit function] The behavior shall be as if the program called the exit function with the status EXIT_SUCCESS at thread termination time.
[7.26.5.5 The thrd_exit function] The thrd_exit function returns no value.
[7.26.5.6 The thrd_join function] The thrd_join function joins the thread identified by thr with the current thread by blocking until the other thread has terminated.
[7.26.5.6 The thrd_join function] If the parameter res is not a null pointer, it stores the thread's result code in the integer pointed to by res.
[7.26.5.6 The thrd_join function] The thread identified by thr shall not have been previously detached or joined with another thread.
[7.26.5.6 The thrd_join function] The thrd_join function returns thrd_success on success or thrd_error if the request could not be honored.
[7.26.5.7 The thrd_sleep function] The thrd_sleep function suspends execution of the calling thread until either the interval specified by duration has elapsed or a signal which is not being ignored is received.
[7.26.5.7 The thrd_sleep function] If interrupted by a signal and the remaining argument is not null, the amount of time remaining (the requested interval minus the time actually slept) is stored in the interval it points to.
[7.26.5.7 The thrd_sleep function] But, except for the case of being interrupted by a signal, the suspension time shall not be less than that specified, as measured by the system clock TIME_UTC.
[7.26.5.7 The thrd_sleep function] The thrd_sleep function returns zero if the requested time has elapsed, -1 if it has been interrupted by a signal, or a negative value if it fails.
[7.26.5.8 The thrd_yield function] The thrd_yield function endeavors to permit other threads to run, even if the current thread would ordinarily continue to run.
[7.26.5.8 The thrd_yield function] The thrd_yield function returns no value.
[7.26.6.1 The tss_create function] The tss_create function creates a thread-specific storage pointer with destructor dtor, which may be null.
[7.26.6.1 The tss_create function] If the tss_create function is successful, it sets the thread-specific storage pointed to by key to a value that uniquely identifies the newly created pointer and returns thrd_success; otherwise, thrd_error is returned and the thread-specific storage pointed to by key is set to an undefined value.
[7.26.6.2 The tss_delete function] The tss_delete function releases any resources used by the thread-specific storage identified by key.
[7.26.6.2 The tss_delete function] The tss_delete function returns no value.
[7.26.6.3 The tss_get function] The tss_get function returns the value for the current thread held in the thread-specific storage identified by key.
[7.26.6.3 The tss_get function] The tss_get function returns the value for the current thread if successful, or zero if unsuccessful.
[7.26.6.4 The tss_set function] The tss_set function sets the value for the current thread held in the thread-specific storage identified by key to val.
[7.26.6.4 The tss_set function] The tss_set function returns thrd_success on success or thrd_error if the request could not be honored.
[7.27.1 Components of time] The timespec structure holds an interval specified in seconds and nanoseconds (which may represent a calendar time based on a particular epoch).
[7.27.1 Components of time] The CLOCKS_PER_SEC macro expands to an expression with type clock_t that is the number per second of the value returned by the clock function
[7.27.1 Components of time] The TIME_UTC macro expands to an integer constant greater than 0 that designates the UTC time base.
[7.27.1 Components of time] The timespec structure shall contain at least the following members, in any order: time_t tv_sec; long tv_nsec.
[7.27.2.1 The clock function] The clock function determines the processor time used.
[7.27.2.1 The clock function] The clock function returns the implementation's best approximation to the processor time used by the program since the beginning of an implementation-defined era related only to the program invocation.
[7.27.2.1 The clock function] If the processor time used is not available or its value cannot be represented, the function returns the value (clock_t)(-1)..
[7.27.2.2 The difftime function] The difftime function computes the difference between two calendar times: time1 -time0.
[7.27.2.2 The difftime function] The difftime function returns the difference expressed in seconds as a double.
[7.27.2.3 The mktime function] The mktime function converts the broken-down time, expressed as local time, in the structure pointed to by timeptr into a calendar time value with the same encoding as that of the values returned by the time function.
[7.27.2.3 The mktime function] A negative value causes it to attempt to determine whether Daylight Saving Time is in effect for the specified time.
[7.27.2.3 The mktime function] The mktime function returns the specified calendar time encoded as a value of type time_t.
[7.27.2.3 The mktime function] If the calendar time cannot be represented, the function returns the value (time_t)(-1).
[7.27.2.4 The time function] The time function determines the current calendar time.
[7.27.2.4 The time function] The time function returns the implementation's best approximation to the current calendar time.
[7.27.2.4 The time function] If timer is not a null pointer, the return value is also assigned to the object it points to.
[7.27.2.5 The timespec_get function] The timespec_get function sets the interval pointed to by ts to hold the current calendar time based on the specified time base.
[7.27.2.5 The timespec_get function] If base is TIME_UTC, the tv_sec member is set to the number of seconds since an implementation defined epoch, truncated to a whole value and the tv_nsec member is set to the integral number of nanoseconds, rounded to the resolution of the system clock. Returns.
[7.27.2.5 The timespec_get function] If the timespec_get function is successful it returns the nonzero value base; otherwise, it returns zero.
[7.27.3 Time conversion functions] The implementation shall behave as if no other library functions call these functions.
[7.27.3.1 The asctime function] The asctime function converts the broken-down time in the structure pointed to by timeptr into a string in the form Sun Sep 16 01:03:52 1973\n\0 using the equivalent of the following algorithm.
[7.27.3.1 The asctime function] If any of the members of the broken-down time contain values that are outside their normal ranges, the behavior of the asctime function is undefined.
[7.27.3.1 The asctime function] The asctime function returns a pointer to the string.
[7.27.3.2 The ctime function] The ctime function converts the calendar time pointed to by timer to local time in the form of a string.
[7.27.3.2 The ctime function] The ctime function returns the pointer returned by the asctime function with that broken-down time as argument.
[7.27.3.3 The gmtime function] The gmtime function converts the calendar time pointed to by timer into a broken-down time, expressed as UTC.
[7.27.3.3 The gmtime function] The gmtime function returns a pointer to the broken-down time, or a null pointer if the specified time cannot be converted to UTC.
[7.27.3.4 The localtime function] The localtime function converts the calendar time pointed to by timer into a broken-down time, expressed as local time.
[7.27.3.4 The localtime function] The localtime function returns a pointer to the broken-down time, or a null pointer if the specified time cannot be converted to local time.
[7.27.3.5 The strftime function] The strftime function places characters into the array pointed to by s as controlled by the string pointed to by format.
[7.27.3.5 The strftime function] The format shall be a multibyte character sequence, beginning and ending in its initial shift state.
[7.27.3.5 The strftime function] A conversion specifier consists of a % character, possibly followed by an E or O modifier character (described below), followed by a character that determines the behavior of the conversion specifier.
[7.27.3.5 The strftime function] If copying takes place between objects that overlap, the behavior is undefined.
[7.27.3.5 The strftime function] If any of the specified values is outside the normal range, the characters stored are unspecified.
[7.27.3.5 The strftime function] If the alternative format or specification does not exist for the current locale, the modifier is ignored.
[7.27.3.5 The strftime function] 4th, which is also the week that includes the first Thursday of the year, and is also the first week that contains at least four days in the year.
[7.27.3.5 The strftime function] If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of the last week of the preceding year; thus, for Saturday 2nd January 1999, %G is replaced by 1998 and %V is replaced by 53.
[7.27.3.5 The strftime function] If December 29th, 30th, or 31st is a Monday, it and any following days are part of week 1 of the following year.
[7.27.3.5 The strftime function] If a conversion specifier is not one of the above, the behavior is undefined.
[7.27.3.5 The strftime function] If the total number of resulting characters including the terminating null character is not more than maxsize, the strftime function returns the number of characters placed into the array pointed to by s not including the terminating null character.
[7.28 Unicode utilities <uchar.h>] The type char16_t is an unsigned integer type used for 16-bit Unicode characters.
[7.28 Unicode utilities <uchar.h>] The type char32_t is an unsigned integer type used for 32-bit Unicode characters.
[7.29.1 Introduction] The type mbstate_t is a complete object type other than an array type that can hold the conversion state information necessary to convert between sequences of multibyte characters and wide characters.
[7.29.1 Introduction] The type wint_t is an integer type unchanged by default argument promotions that can hold any value corresponding to members of the extended character set, as well as at least one value that does not correspond to any member of the extended character set.
[7.29.1 Introduction] The type struct tm holds the components of a calendar time, called the broken-down time.
[7.29.1 Introduction] WEOF which expands to a constant expression of type wint_t whose value does not correspond to any member of the extended character set. It is accepted (and returned) by several functions in this subclause to indicate end-of-file, that is, no more input from a stream.
[7.29.1 Introduction] Such values shall be processed according to the specified semantics, except that it is unspecified whether an encoding error occurs if such a value appears in the format string for a function in 7.29.2 or 7.29.5 and the specified semantics do not require that value to be processed by wcrtomb.
[7.29.2 Formatted wide character input/output functions] The formatted wide character input/output functions shall behave as if there is a sequence point after the actions associated with each specifier..
[7.29.2 Formatted wide character input/output functions] The fwprintf functions perform writes to memory for the %n specifier.
[7.29.2.1 The fwprintf function] The fwprintf function writes output to the stream pointed to by stream, under control of the wide string pointed to by format that specifies how subsequent arguments are converted for output.
[7.29.2.1 The fwprintf function] If there are insufficient arguments for the format, the behavior is undefined.
[7.29.2.1 The fwprintf function] If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.
[7.29.2.1 The fwprintf function] The number of wide characters that can be produced by any single conversion shall be at least 4095.
[7.29.2.2 The fwscanf function] The fwscanf function reads input from the stream pointed to by stream, under control of the wide string pointed to by format that specifies the admissible input sequences and how they are to be converted for assignment, using subsequent arguments as pointers to the objects to receive the converted input.
[7.29.2.2 The fwscanf function] If there are insufficient arguments for the format, the behavior is undefined.
[7.29.2.2 The fwscanf function] If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.
[7.29.2.2 The fwscanf function] The fwscanf function executes each directive of the format in turn.
[7.29.2.2 The fwscanf function] When all directives have been executed, or if a directive fails (as detailed below), the function returns.
[7.29.2.2 The fwscanf function] A directive composed of white-space wide character(s) is executed by reading input up to the first non-white-space wide character (which remains unread), or until no more wide characters can be read.
[7.29.2.2 The fwscanf function] A directive that is an ordinary wide character is executed by reading the next wide character of the stream.
[7.29.2.2 The fwscanf function] If that wide character differs from the directive, the directive fails and the differing and subsequent wide characters remain unread.
[7.29.2.2 The fwscanf function] A directive that is a conversion specification defines a set of matching input sequences, as described below for each specifier.
[7.29.2.2 The fwscanf function] A conversion specification is executed in the following steps:.
[7.29.2.2 The fwscanf function] An input item is read from the stream, unless the specification includes an n specifier.
[7.29.2.2 The fwscanf function] An input item is defined as the longest sequence of input wide characters which does not exceed any specified field width and which is, or is a prefix of, a matching input sequence. The first wide character, if any, after the input item remains unread.
[7.29.2.2 The fwscanf function] If the length of the input item is zero, the execution of the directive fails; this condition is a matching failure unless end-of-file, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.
[7.29.2.2 The fwscanf function] If the input item is not a matching sequence, the execution of the directive fails: this condition is a matching failure.
[7.29.2.2 The fwscanf function] If this object does not have an appropriate type, or if the result of the conversion cannot be represented in the object, the behavior is undefined.
[7.29.2.2 The fwscanf function] If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to signed integer.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to signed integer.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to unsigned integer.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to unsigned integer.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to unsigned integer.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to floating.
[7.29.2.2 The fwscanf function] If no l length modifier is present, characters from the input field are converted as if by repeated calls to the wcrtomb function, with the conversion state described by an mbstate_t object initialized to zero before the first wide character is converted.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to the initial element of a character array large enough to accept the sequence.
[7.29.2.2 The fwscanf function] If an l length modifier is present, the corresponding argument shall be a pointer to the initial element of an array of wchar_t large enough to accept the sequence.
[7.29.2.2 The fwscanf function] If no l length modifier is present, characters from the input field are converted as if by repeated calls to the wcrtomb function, with the conversion state described by an mbstate_t object initialized to zero before the first wide character is converted.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to the initial element of a character array large enough to accept the sequence and a terminating null character, which will be added automatically.
[7.29.2.2 The fwscanf function] If an l length modifier is present, the corresponding argument shall be a pointer to the initial element of an array of wchar_t large enough to accept the sequence and the terminating null wide character, which will be added automatically.
[7.29.2.2 The fwscanf function] If no l length modifier is present, characters from the input field are converted as if by repeated calls to the wcrtomb function, with the conversion state described by an mbstate_t object initialized to zero before the first wide character is converted.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to the initial element of a character array large enough to accept the sequence and a terminating null character, which will be added automatically.
[7.29.2.2 The fwscanf function] If an l length modifier is present, the corresponding argument shall be a pointer to the initial element of an array of wchar_t large enough to accept the sequence and the terminating null wide character, which will be added automatically.
[7.29.2.2 The fwscanf function] If the conversion specifier begins with [] or [^], the right bracket wide character is in the scanlist and the next following right bracket wide character is the matching right bracket that ends the specification; otherwise the first following right bracket wide character is the one that ends the specification.
[7.29.2.2 The fwscanf function] If a -wide character is in the scanlist and is not the first, nor the second where the first wide character is a ^, nor the last character, the behavior is implementation-defined.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to a pointer to void.
[7.29.2.2 The fwscanf function] If the input item is a value converted earlier during the same program execution, the pointer that results shall compare equal to that value; otherwise the behavior of the %p conversion is undefined.
[7.29.2.2 The fwscanf function] The corresponding argument shall be a pointer to signed integer into which is to be written the number of wide characters read from the input stream so far by this call to the fwscanf function.
[7.29.2.2 The fwscanf function] If the conversion specification includes an assignment-suppressing wide character or a field width, the behavior is undefined.
[7.29.2.2 The fwscanf function] The complete conversion specification shall be %%.
[7.29.2.2 The fwscanf function] If a conversion specification is invalid, the behavior is undefined..
[7.29.2.2 The fwscanf function] The fwscanf function returns the value of the macro EOF if an input failure occurs before the first conversion (if any) has completed.
[7.29.2.3 The swprintf function] The swprintf function is equivalent to fwprintf, except that the argument s specifies an array of wide characters into which the generated output is to be written, rather than written to a stream.
[7.29.2.3 The swprintf function] character, which is always added (unless n is zero).
[7.29.2.3 The swprintf function] The swprintf function returns the number of wide characters written in the array, not counting the terminating null wide character, or a negative value if an encoding error occurred or if n or more wide characters were requested to be written.
[7.29.2.4 The swscanf function] The swscanf function is equivalent to fwscanf, except that the argument s specifies a wide string from which the input is to be obtained, rather than from a stream.
[7.29.2.4 The swscanf function] The swscanf function returns the value of the macro EOF if an input failure occurs before the first conversion (if any) has completed.
[7.29.2.5 The vfwprintf function] The vfwprintf function is equivalent to fwprintf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.29.2.5 The vfwprintf function] The vfwprintf function does not invoke the va_end macro. Returns.
[7.29.2.5 The vfwprintf function] The vfwprintf function returns the number of wide characters transmitted, or a negative value if an output or encoding error occurred.
[7.29.2.6 The vfwscanf function] The vfwscanf function is equivalent to fwscanf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.29.2.6 The vfwscanf function] The vfwscanf function does not invoke the va_end macro. Returns.
[7.29.2.6 The vfwscanf function] The vfwscanf function returns the value of the macro EOF if an input failure occurs before the first conversion (if any) has completed.
[7.29.2.7 The vswprintf function] The vswprintf function is equivalent to swprintf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.29.2.7 The vswprintf function] The vswprintf function does not invoke the va_end macro. Returns.
[7.29.2.7 The vswprintf function] The vswprintf function returns the number of wide characters written in the array, not counting the terminating null wide character, or a negative value if an encoding error occurred or if n or more wide characters were requested to be generated.
[7.29.2.8 The vswscanf function] The vswscanf function is equivalent to swscanf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.29.2.8 The vswscanf function] The vswscanf function does not invoke the va_end macro. Returns.
[7.29.2.8 The vswscanf function] The vswscanf function returns the value of the macro EOF if an input failure occurs before the first conversion (if any) has completed.
[7.29.2.9 The vwprintf function] The vwprintf function is equivalent to wprintf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.29.2.9 The vwprintf function] The vwprintf function does not invoke the va_end macro. Returns.
[7.29.2.9 The vwprintf function] The vwprintf function returns the number of wide characters transmitted, or a negative value if an output or encoding error occurred.
[7.29.2.10 The vwscanf function] The vwscanf function is equivalent to wscanf, with the variable argument list replaced by arg, which shall have been initialized by the va_start macro (and possibly subsequent va_arg calls).
[7.29.2.10 The vwscanf function] The vwscanf function does not invoke the va_end macro. Returns.
[7.29.2.10 The vwscanf function] The vwscanf function returns the value of the macro EOF if an input failure occurs before the first conversion (if any) has completed.
[7.29.2.11 The wprintf function] The wprintf function is equivalent to fwprintf with the argument stdout interposed before the arguments to wprintf.
[7.29.2.11 The wprintf function] The wprintf function returns the number of wide characters transmitted, or a negative value if an output or encoding error occurred.
[7.29.2.12 The wscanf function] The wscanf function is equivalent to fwscanf with the argument stdin interposed before the arguments to wscanf.
[7.29.2.12 The wscanf function] The wscanf function returns the value of the macro EOF if an input failure occurs before the first conversion (if any) has completed.
[7.29.3.1 The fgetwc function] If the end-of-file indicator for the input stream pointed to by stream is not set and a next wide character is present, the fgetwc function obtains that wide character as a wchar_t converted to a wint_t and advances the associated file position indicator for the stream (if defined).
[7.29.3.1 The fgetwc function] If the end-of-file indicator for the stream is set, or if the stream is at end-of-file, the end-of-file indicator for the stream is set and the fgetwc function returns WEOF.
[7.29.3.1 The fgetwc function] If a read error occurs, the error indicator for the stream is set and the fgetwc function returns WEOF.
[7.29.3.1 The fgetwc function] If an encoding error occurs (including too few bytes), the value of the macro EILSEQ is stored in errno and the fgetwc function returns WEOF..
[7.29.3.1 The fgetwc function] An end-of-file and a read error can be distinguished by use of the feof and ferror functions.
[7.29.3.2 The fgetws function] The fgetws function reads at most one less than the number of wide characters specified by n from the stream pointed to by stream into the array pointed to by s.
[7.29.3.2 The fgetws function] A null wide character is written immediately after the last wide character read into the array.
[7.29.3.2 The fgetws function] The fgetws function returns s if successful.
[7.29.3.2 The fgetws function] If end-of-file is encountered and no characters have been read into the array, the contents of the array remain unchanged and a null pointer is returned.
[7.29.3.2 The fgetws function] If a read or encoding error occurs during the operation, the array contents are indeterminate and a null pointer is returned.
[7.29.3.3 The fputwc function] The fputwc function writes the wide character specified by c to the output stream pointed to by stream, at the position indicated by the associated file position indicator for the stream (if defined), and advances the indicator appropriately.
[7.29.3.3 The fputwc function] If the file cannot support positioning requests, or if the stream was opened with append mode, the character is appended to the output stream.
[7.29.3.3 The fputwc function] The fputwc function returns the wide character written.
[7.29.3.3 The fputwc function] If a write error occurs, the error indicator for the stream is set and fputwc returns WEOF.
[7.29.3.3 The fputwc function] If an encoding error occurs, the value of the macro EILSEQ is stored in errno and fputwc returns WEOF.
[7.29.3.4 The fputws function] The fputws function writes the wide string pointed to by s to the stream pointed to by stream.
[7.29.3.4 The fputws function] The fputws function returns EOF if a write or encoding error occurs; otherwise, it returns a nonnegative value.
[7.29.3.5 The fwide function] The fwide function determines the orientation of the stream pointed to by stream.
[7.29.3.5 The fwide function] If mode is greater than zero, the function first attempts to make the stream wide oriented.
[7.29.3.5 The fwide function] If mode is less than zero, the function first attempts to make the stream byte oriented. Otherwise, mode is zero and the function does not alter the orientation of the stream.
[7.29.3.5 The fwide function] If the orientation of the stream has already been determined, fwide does not change it.
[7.29.3.5 The fwide function] The fwide function returns a value greater than zero if, after the call, the stream has wide orientation, a value less than zero if the stream has byte orientation, or zero if the stream has no orientation.
[7.29.3.6 The getwc function] The getwc function is equivalent to fgetwc, except that if it is implemented as a macro, it may evaluate stream more than once, so the argument should never be an expression with side effects.
[7.29.3.6 The getwc function] The getwc function returns the next wide character from the input stream pointed to by stream, or WEOF.
[7.29.3.7 The getwchar function] The getwchar function is equivalent to getwc with the argument stdin.
[7.29.3.7 The getwchar function] The getwchar function returns the next wide character from the input stream pointed to by stdin, or WEOF.
[7.29.3.8 The putwc function] The putwc function is equivalent to fputwc, except that if it is implemented as a macro, it may evaluate stream more than once, so that argument should never be an expression with side effects.
[7.29.3.8 The putwc function] The putwc function returns the wide character written, or WEOF.
[7.29.3.9 The putwchar function] The putwchar function is equivalent to putwc with the second argument stdout.
[7.29.3.9 The putwchar function] The putwchar function returns the character written, or WEOF.
[7.29.3.10 The ungetwc function] The ungetwc function pushes the wide character specified by c back onto the input stream pointed to by stream.
[7.29.3.10 The ungetwc function] A successful intervening call (with the stream pointed to by stream) to a file positioning function (fseek, fsetpos, or rewind) discards any pushed-back wide characters for the stream.
[7.29.3.10 The ungetwc function] If the ungetwc function is called too many times on the same stream without an intervening read or file positioning operation on that stream, the operation may fail.
[7.29.3.10 The ungetwc function] If the value of c equals that of the macro WEOF, the operation fails and the input stream is unchanged.
[7.29.3.10 The ungetwc function] The ungetwc function returns the wide character pushed back, or WEOF if the operation fails.
[7.29.4 General wide string utilities] If an array is accessed beyond the end of an object, the behavior is undefined.
[7.29.4 General wide string utilities] Unless explicitly stated otherwise in the description of a particular function in this subclause, pointer arguments on such a call shall still have valid values, as described in 7.1.4.
[7.29.4.1.1 The wcstod, wcstof, and wcstold functions] If the subject sequence begins with a minus sign, the sequence is interpreted as negated. A wide character sequence INF or INFINITY is interpreted as an infinity, if representable in the return type, else like a floating constant that is too large for the range of the return type.
[7.29.4.1.1 The wcstod, wcstof, and wcstold functions] A wide character sequence NAN or NAN(n-wchar-sequenceopt) is interpreted as a quiet NaN, if supported in the return type, else like a subject sequence part that does not have the expected form; the meaning of the n-wchar sequence is implementation-defined.
[7.29.4.1.1 The wcstod, wcstof, and wcstold functions] If the subject sequence has the hexadecimal form and FLT_RADIX is a power of 2, the value resulting from the conversion is correctly rounded.
[7.29.4.1.1 The wcstod, wcstof, and wcstold functions] If the subject sequence is empty or does not have the expected form, no conversion is performed; the value of nptr is stored in the object pointed to by endptr, provided that endptr is not a null pointer.
[7.29.4.1.1 The wcstod, wcstof, and wcstold functions] If no conversion could be performed, zero is returned.
[7.29.4.1.1 The wcstod, wcstof, and wcstold functions] If the correct value overflows and default rounding is in effect (7.12., plus or minus HUGE_VAL, HUGE_VALF, or HUGE_VALL is returned (according to the return type and sign of the value), and the value of the macro ERANGE is stored in errno.
[7.29.4.1.1 The wcstod, wcstof, and wcstold functions] If the result underflows, the functions return a value whose magnitude is no greater than the smallest normalized positive number in the return type; whether errno acquires the value ERANGE is implementation-defined.
[7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions] If the value of base is zero, the expected form of the subject sequence is that of an integer constant as described for the corresponding single-byte characters in 6.4.4.1, optionally preceded by a plus or minus sign, but not including an integer suffix.
[7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions] If the value of base is between 2 and 36 (inclusive), the expected form of the subject sequence is a sequence of letters and digits representing an integer with the radix specified by base, optionally preceded by a plus or minus sign, but not including an integer suffix.
[7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions] If the value of base is 16, the wide characters 0x or 0X may optionally precede the sequence of letters and digits, following the sign if present.
[7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions] If the subject sequence has the expected form and the value of base is zero, the sequence of wide characters starting with the first digit is interpreted as an integer constant according to the rules of 6.4.4.1.
[7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions] If the subject sequence has the expected form and the value of base is between 2 and 36, it is used as the base for conversion, ascribing to each letter its value as given above.
[7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions] If the subject sequence begins with a minus sign, the value resulting from the conversion is negated (in the return type).
[7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions] A pointer to the final wide string is stored in the object pointed to by endptr, provided that endptr is not a null pointer.
[7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions] If the subject sequence is empty or does not have the expected form, no conversion is performed; the value of nptr is stored in the object pointed to by endptr, provided that endptr is not a null pointer.
[7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions] If no conversion could be performed, zero is returned.
[7.29.4.1.2 The wcstol, wcstoll, wcstoul, and wcstoull functions] If the correct value is outside the range of representable values, LONG_MIN, LONG_MAX, LLONG_MIN, LLONG_MAX, ULONG_MAX, or ULLONG_MAX is returned (according to the return type sign of the value, if any), and the value of the macro ERANGE is stored in errno.
[7.29.4.2.1 The wcscpy function] The wcscpy function copies the wide string pointed to by s2 (including the terminating null wide character) into the array pointed to by s1.
[7.29.4.2.1 The wcscpy function] The wcscpy function returns the value of s1.
[7.29.4.2.2 The wcsncpy function] The wcsncpy function copies not more than n wide characters (those that follow a null wide character are not copied) from the array pointed to by s2 to the array pointed to by s1..
[7.29.4.2.2 The wcsncpy function] If the array pointed to by s2 is a wide string that is shorter than n wide characters, null wide characters are appended to the copy in the array pointed to by s1, until n wide characters in all have been written.
[7.29.4.2.2 The wcsncpy function] The wcsncpy function returns the value of s1.
[7.29.4.2.3 The wmemcpy function] The wmemcpy function copies n wide characters from the object pointed to by s2 to the object pointed to by s1.
[7.29.4.2.3 The wmemcpy function] The wmemcpy function returns the value of s1.
[7.29.4.2.4 The wmemmove function] The wmemmove function copies n wide characters from the object pointed to by s2 to the object pointed to by s1.
[7.29.4.2.4 The wmemmove function] The wmemmove function returns the value of s1.
[7.29.4.3.1 The wcscat function] The wcscat function appends a copy of the wide string pointed to by s2 (including the terminating null wide character) to the end of the wide string pointed to by s1.
[7.29.4.3.1 The wcscat function] The wcscat function returns the value of s1.
[7.29.4.3.2 The wcsncat function] The wcsncat function appends not more than n wide characters (a null wide character and those that follow it are not appended) from the array pointed to by s2 to the end of the wide string pointed to by s1.
[7.29.4.3.2 The wcsncat function] A terminating null wide character is always appended to the result. Returns.
[7.29.4.3.2 The wcsncat function] The wcsncat function returns the value of s1.
[7.29.4.4.1 The wcscmp function] The wcscmp function compares the wide string pointed to by s1 to the wide string pointed to by s2.
[7.29.4.4.1 The wcscmp function] The wcscmp function returns an integer greater than, equal to, or less than zero, accordingly as the wide string pointed to by s1 is greater than, equal to, or less than the wide string pointed to by s2.
[7.29.4.4.2 The wcscoll function] The wcscoll function compares the wide string pointed to by s1 to the wide string pointed to by s2, both interpreted as appropriate to the LC_COLLATE category of the current locale.
[7.29.4.4.2 The wcscoll function] The wcscoll function returns an integer greater than, equal to, or less than zero, accordingly as the wide string pointed to by s1 is greater than, equal to, or less than the wide string pointed to by s2 when both are interpreted as appropriate to the current locale.
[7.29.4.4.3 The wcsncmp function] The wcsncmp function compares not more than n wide characters (those that follow a null wide character are not compared) from the array pointed to by s1 to the array pointed to by s2.
[7.29.4.4.3 The wcsncmp function] The wcsncmp function returns an integer greater than, equal to, or less than zero, accordingly as the possibly null-terminated array pointed to by s1 is greater than, equal to, or less than the possibly null-terminated array pointed to by s2.
[7.29.4.4.4 The wcsxfrm function] The wcsxfrm function transforms the wide string pointed to by s2 and places the resulting wide string into the array pointed to by s1.
[7.29.4.4.4 The wcsxfrm function] If n is zero, s1 is permitted to be a null pointer.
[7.29.4.4.4 The wcsxfrm function] The wcsxfrm function returns the length of the transformed wide string (not including the terminating null wide character).
[7.29.4.4.4 The wcsxfrm function] If the value returned is n or greater, the contents of the array pointed to by s1 are indeterminate.
[7.29.4.4.5 The wmemcmp function] The wmemcmp function compares the first n wide characters of the object pointed to by s1 to the first n wide characters of the object pointed to by s2.
[7.29.4.4.5 The wmemcmp function] The wmemcmp function returns an integer greater than, equal to, or less than zero, accordingly as the object pointed to by s1 is greater than, equal to, or less than the object pointed to by s2.
[7.29.4.5.1 The wcschr function] The wcschr function locates the first occurrence of c in the wide string pointed to by s.
[7.29.4.5.1 The wcschr function] The wcschr function returns a pointer to the located wide character, or a null pointer if the wide character does not occur in the wide string.
[7.29.4.5.2 The wcscspn function] The wcscspn function computes the length of the maximum initial segment of the wide string pointed to by s1 which consists entirely of wide characters not from the wide string pointed to by s2.
[7.29.4.5.2 The wcscspn function] The wcscspn function returns the length of the segment.
[7.29.4.5.3 The wcspbrk function] The wcspbrk function locates the first occurrence in the wide string pointed to by s1 of any wide character from the wide string pointed to by s2.
[7.29.4.5.3 The wcspbrk function] The wcspbrk function returns a pointer to the wide character in s1, or a null pointer if no wide character from s2 occurs in s1.
[7.29.4.5.4 The wcsrchr function] The wcsrchr function locates the last occurrence of c in the wide string pointed to by s.
[7.29.4.5.4 The wcsrchr function] The wcsrchr function returns a pointer to the wide character, or a null pointer if c does not occur in the wide string.
[7.29.4.5.5 The wcsspn function] The wcsspn function computes the length of the maximum initial segment of the wide string pointed to by s1 which consists entirely of wide characters from the wide string pointed to by s2.
[7.29.4.5.5 The wcsspn function] The wcsspn function returns the length of the segment.
[7.29.4.5.6 The wcsstr function] The wcsstr function locates the first occurrence in the wide string pointed to by s1 of the sequence of wide characters (excluding the terminating null wide character) in the wide string pointed to by s2.
[7.29.4.5.6 The wcsstr function] The wcsstr function returns a pointer to the located wide string, or a null pointer if the wide string is not found.
[7.29.4.5.6 The wcsstr function] If s2 points to a wide string with zero length, the function returns s1.
[7.29.4.5.7 The wcstok function] A sequence of calls to the wcstok function breaks the wide string pointed to by s1 into a sequence of tokens, each of which is delimited by a wide character from the wide string pointed to by s2.
[7.29.4.5.7 The wcstok function] sequence, which is then updated.
[7.29.4.5.7 The wcstok function] If no such wide character is found, then there are no tokens in the wide string pointed to by s1 and the wcstok function returns a null pointer.
[7.29.4.5.7 The wcstok function] If such a wide character is found, it is the start of the first token.
[7.29.4.5.7 The wcstok function] The wcstok function then searches from there for a wide character that is contained in the current separator wide string.
[7.29.4.5.7 The wcstok function] If no such wide character is found, the current token extends to the end of the wide string pointed to by s1, and subsequent searches in the same wide string for a token return a null pointer.
[7.29.4.5.7 The wcstok function] If such a wide character is found, it is overwritten by a null wide character, which terminates the current token.
[7.29.4.5.7 The wcstok function] In all cases, the wcstok function stores sufficient information in the pointer pointed to by ptr so that subsequent calls, with a null pointer for s1 and the unmodified pointer value for ptr, shall start searching just past the element overwritten by a null wide character (if any).
[7.29.4.5.7 The wcstok function] The wcstok function returns a pointer to the first wide character of a token, or a null pointer if there is no token.
[7.29.4.5.8 The wmemchr function] The wmemchr function locates the first occurrence of c in the initial n wide characters of the object pointed to by s.
[7.29.4.5.8 The wmemchr function] The wmemchr function returns a pointer to the located wide character, or a null pointer if the wide character does not occur in the object.
[7.29.4.6.1 The wcslen function] The wcslen function computes the length of the wide string pointed to by s.
[7.29.4.6.1 The wcslen function] The wcslen function returns the number of wide characters that precede the terminating null wide character.
[7.29.4.6.2 The wmemset function] The wmemset function copies the value of c into each of the first n wide characters of the object pointed to by s.
[7.29.4.6.2 The wmemset function] The wmemset function returns the value of s.
[7.29.5.1 The wcsftime function] The wcsftime function is equivalent to the strftime function, except that: -- The argument s points to the initial element of an array of wide characters into which the generated output is to be placed.
[7.29.5.1 The wcsftime function] If the total number of resulting wide characters including the terminating null wide character is not more than maxsize, the wcsftime function returns the number of wide characters placed into the array pointed to by s not including the terminating null wide character.
[7.29.6 Extended multibyte/wide character conversion utilities] A zero-valued mbstate_t object is (at least) one way to describe an initial conversion state.
[7.29.6 Extended multibyte/wide character conversion utilities] If an mbstate_t object has been altered by any of the functions described in this subclause, and is then used with a different multibyte character sequence, or in the other conversion direction, or with a different LC_CTYPE category setting than on earlier function calls, the behavior is undefined..
[7.29.6.1.1 The btowc function] The btowc function determines whether c constitutes a valid single-byte character in the initial shift state.
[7.29.6.1.1 The btowc function] The btowc function returns WEOF if c has the value EOF or if (unsigned char)c does not constitute a valid single-byte character in the initial shift state.
[7.29.6.1.2 The wctob function] The wctob function determines whether c corresponds to a member of the extended character set whose multibyte character representation is a single byte when in the initial shift state.
[7.29.6.1.2 The wctob function] The wctob function returns EOF if c does not correspond to a multibyte character with length one in the initial shift state.
[7.29.6.2.1 The mbsinit function] If ps is not a null pointer, the mbsinit function determines whether the referenced mbstate_t object describes an initial conversion state.
[7.29.6.2.1 The mbsinit function] The mbsinit function returns nonzero if ps is a null pointer or if the referenced object describes an initial conversion state; otherwise, it returns zero.
[7.29.6.3 Restartable multibyte/wide character conversion functions] If ps is a null pointer, each function uses its own internal mbstate_t object instead, which is initialized at program startup to the initial conversion state; the functions are not required to avoid data races with other calls to the same function in this case.
[7.29.6.3.1 The mbrlen function] The mbrlen function is equivalent to the call: mbrtowc(NULL, s, n, ps != NULL ? ps : &internal) where internal is the mbstate_t object for the mbrlen function, except that the expression designated by ps is evaluated only once.
[7.29.6.3.1 The mbrlen function] The mbrlen function returns a value between zero and n, inclusive, (size_t)(-2), or (size_t)(-1).
[7.29.6.3.2 The mbrtowc function] If s is a null pointer, the mbrtowc function is equivalent to the call: mbrtowc(NULL, "", 1, ps) In this case, the values of the parameters pwc and n are ignored.
[7.29.6.3.2 The mbrtowc function] If s is not a null pointer, the mbrtowc function inspects at most n bytes beginning with the byte pointed to by s to determine the number of bytes needed to complete the next multibyte character (including any shift sequences).
[7.29.6.3.2 The mbrtowc function] If the function determines that the next multibyte character is complete and valid, it determines the value of the corresponding wide character and then, if pwc is not a null pointer, stores that value in the object pointed to by pwc.
[7.29.6.3.2 The mbrtowc function] If the corresponding wide character is the null wide character, the resulting state described is the initial conversion state.
[7.29.6.3.2 The mbrtowc function] The mbrtowc function returns the first of the following that applies (given the current conversion state): 0 if the next n or fewer bytes complete the multibyte character that corresponds to the null wide character (which is the value stored).
[7.29.6.3.2 The mbrtowc function] When n has at least the value of the MB_CUR_MAX macro, this case can only occur if s points at a sequence of redundant shift sequences (for implementations with state-dependent encodings).
[7.29.6.3.3 The wcrtomb function] If s is a null pointer, the wcrtomb function is equivalent to the call wcrtomb(buf, L'\0', ps) where buf is an internal buffer.
[7.29.6.3.3 The wcrtomb function] If s is not a null pointer, the wcrtomb function determines the number of bytes needed to represent the multibyte character that corresponds to the wide character given by wc (including any shift sequences), and stores the multibyte character representation in the array whose first element is pointed to by s.
[7.29.6.3.3 The wcrtomb function] If wc is a null wide character, a null byte is stored, preceded by any shift sequence needed to restore the initial shift state; the resulting state described is the initial conversion state.
[7.29.6.3.3 The wcrtomb function] The wcrtomb function returns the number of bytes stored in the array object (including any shift sequences).
[7.29.6.3.3 The wcrtomb function] When wc is not a valid wide character, an encoding error occurs: the function stores the value of the macro EILSEQ in errno and returns (size_t)(-1); the conversion state is unspecified.
[7.29.6.4 Restartable multibyte/wide string conversion functions] If ps is a null pointer, each function uses its own internal mbstate_t object instead, which is initialized at program startup to the initial conversion state; the functions are not required to avoid data races with other calls to the same function in this case.
[7.29.6.4 Restartable multibyte/wide string conversion functions] When the function is storing the results of conversions (that is, when dst is not a null pointer), the pointer object pointed to by this parameter is updated to reflect the amount of the source processed by that invocation.
[7.29.6.4.1 The mbsrtowcs function] The mbsrtowcs function converts a sequence of multibyte characters that begins in the conversion state described by the object pointed to by ps, from the array indirectly pointed to by src into a sequence of corresponding wide characters.
[7.29.6.4.1 The mbsrtowcs function] If dst is not a null pointer, the converted characters are stored into the array pointed to by dst.
[7.29.6.4.1 The mbsrtowcs function] character, which is also stored.
[7.29.6.4.1 The mbsrtowcs function] If dst is not a null pointer, the pointer object pointed to by src is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last multibyte character converted (if any).
[7.29.6.4.1 The mbsrtowcs function] If conversion stopped due to reaching a terminating null character and if dst is not a null pointer, the resulting state described is the initial conversion state.
[7.29.6.4.1 The mbsrtowcs function] If the input conversion encounters a sequence of bytes that do not form a valid multibyte character, an encoding error occurs: the mbsrtowcs function stores the value of the macro EILSEQ in errno and returns (size_t)(-1); the conversion state is unspecified.
[7.29.6.4.2 The wcsrtombs function] The wcsrtombs function converts a sequence of wide characters from the array indirectly pointed to by src into a sequence of corresponding multibyte characters that begins in the conversion state described by the object pointed to by ps.
[7.29.6.4.2 The wcsrtombs function] If dst is not a null pointer, the converted characters are then stored into the array pointed to by dst.
[7.29.6.4.2 The wcsrtombs function] character, which is also stored.
[7.29.6.4.2 The wcsrtombs function] If conversion stops because a terminating null wide character has been reached, the bytes stored include those necessary to reach the initial shift state immediately before the null byte.
[7.29.6.4.2 The wcsrtombs function] If dst is not a null pointer, the pointer object pointed to by src is assigned either a null pointer (if conversion stopped due to reaching a terminating null wide character) or the address just past the last wide character converted (if any).
[7.29.6.4.2 The wcsrtombs function] If conversion stopped due to reaching a terminating null wide character, the resulting state described is the initial conversion state.
[7.29.6.4.2 The wcsrtombs function] If conversion stops because a wide character is reached that does not correspond to a valid multibyte character, an encoding error occurs: the wcsrtombs function stores the value of the macro EILSEQ in errno and returns (size_t)(-1); the conversion state is unspecified.
[7.30.1 Introduction] wctrans_t which is a scalar type that can hold values which represent locale-specific character mappings; and wctype_t which is a scalar type that can hold values which represent locale-specific character classifications.
[7.30.1 Introduction] For all functions described in this subclause that accept an argument of type wint_t, the value shall be representable as a wchar_t or shall equal the value of the macro WEOF.
[7.30.1 Introduction] If this argument has any other value, the behavior is undefined.
[7.30.2.1.1 The iswalnum function] The iswalnum function tests for any wide character for which iswalpha or iswdigit is true.
[7.30.2.1.2 The iswalpha function] The iswalpha function tests for any wide character for which iswupper or iswlower is true, or any wide character that is one of a locale-specific set of alphabetic wide characters for which none of iswcntrl, iswdigit, iswpunct, or iswspace is true..
[7.30.2.1.3 The iswblank function] The iswblank function tests for any wide character that is a standard blank wide character or is one of a locale-specific set of wide characters for which iswspace is true and that is used to separate words within a line of text.
[7.30.2.1.4 The iswcntrl function] The iswcntrl function tests for any control wide character.
[7.30.2.1.5 The iswdigit function] The iswdigit function tests for any wide character that corresponds to a decimal-digit character (as defined in 5.2..
[7.30.2.1.6 The iswgraph function] The iswgraph function tests for any wide character for which iswprint is true and iswspace is false..
[7.30.2.1.7 The iswlower function] The iswlower function tests for any wide character that corresponds to a lowercase letter or is one of a locale-specific set of wide characters for which none of iswcntrl, iswdigit, iswpunct, or iswspace is true.
[7.30.2.1.8 The iswprint function] The iswprint function tests for any printing wide character.
[7.30.2.1.9 The iswpunct function] The iswpunct function tests for any printing wide character that is one of a locale-specific set of punctuation wide characters for which neither iswspace nor iswalnum is true..
[7.30.2.1.10 The iswspace function] The iswspace function tests for any wide character that corresponds to a locale-specific set of white-space wide characters for which none of iswalnum, iswgraph, or iswpunct is true.
[7.30.2.1.11 The iswupper function] The iswupper function tests for any wide character that corresponds to an uppercase letter or is one of a locale-specific set of wide characters for which none of iswcntrl, iswdigit, iswpunct, or iswspace is true.
[7.30.2.1.12 The iswxdigit function] The iswxdigit function tests for any wide character that corresponds to a hexadecimal-digit character (as defined in 6.4.4..
[7.30.2.2.1 The iswctype function] The iswctype function determines whether the wide character wc has the property described by desc.
[7.30.2.2.1 The iswctype function] The current setting of the LC_CTYPE category shall be the same as during the call to wctype that returned the value desc.
[7.30.2.2.1 The iswctype function] The iswctype function returns nonzero (true) if and only if the value of the wide character wc has the property described by desc.
[7.30.2.2.1 The iswctype function] If desc is zero, the iswctype function returns zero (false).
[7.30.2.2.2 The wctype function] The wctype function constructs a value with type wctype_t that describes a class of wide characters identified by the string argument property.
[7.30.2.2.2 The wctype function] The strings listed in the description of the iswctype function shall be valid in all locales as property arguments to the wctype function.
[7.30.2.2.2 The wctype function] If property identifies a valid class of wide characters according to the LC_CTYPE category of the current locale, the wctype function returns a nonzero value that is valid as the second argument to the iswctype function; otherwise, it returns zero.
[7.30.3.1.1 The towlower function] The towlower function converts an uppercase letter to a corresponding lowercase letter.
[7.30.3.1.1 The towlower function] If the argument is a wide character for which iswupper is true and there are one or more corresponding wide characters, as specified by the current locale, for which iswlower is true, the towlower function returns one of the corresponding wide characters (always the same one for any given locale); otherwise, the argument is returned unchanged.
[7.30.3.1.2 The towupper function] The towupper function converts a lowercase letter to a corresponding uppercase letter.
[7.30.3.1.2 The towupper function] If the argument is a wide character for which iswlower is true and there are one or more corresponding wide characters, as specified by the current locale, for which iswupper is true, the towupper function returns one of the corresponding wide characters (always the same one for any given locale); otherwise, the argument is returned unchanged.
[7.30.3.2.1 The towctrans function] The towctrans function maps the wide character wc using the mapping described by desc.
[7.30.3.2.1 The towctrans function] The current setting of the LC_CTYPE category shall be the same as during the call to wctrans that returned the value desc.
[7.30.3.2.1 The towctrans function] The towctrans function returns the mapped value of wc using the mapping described by desc.
[7.30.3.2.1 The towctrans function] If desc is zero, the towctrans function returns the value of wc.
[7.30.3.2.2 The wctrans function] The wctrans function constructs a value with type wctrans_t that describes a mapping between wide characters identified by the string argument property.
[7.30.3.2.2 The wctrans function] The strings listed in the description of the towctrans function shall be valid in all locales as property arguments to the wctrans function.
[7.30.3.2.2 The wctrans function] If property identifies a valid mapping of wide characters according to the LC_CTYPE category of the current locale, the wctrans function returns a nonzero value that is valid as the second argument to the towctrans function; otherwise, it returns zero.
[F.5 Binary-decimal conversion] If the minimum-width IEC 60559 extended format (64 bits of precision) is supported, DECIMAL_DIG shall be at least 21.
[F.5 Binary-decimal conversion] If IEC 60559 double (53 bits of precision) is the widest IEC 60559 format supported, then DECIMAL_DIG shall be at least 17.
[F.6 The return statement] If the return expression is evaluated in a floating-point format different from the return type, the expression is converted as if by assignment to the return type of the function and the resulting value is returned to the caller.
[F.7 Contracted expressions] A contracted expression is correctly rounded (once) and treats infinities, NaNs, signed zeros, subnormals, and the rounding directions in a manner consistent with the basic arithmetic operations covered by IEC 60559.
[F.7 Contracted expressions] A contracted expression should raise floating-point exceptions in a manner generally consistent with the basic arithmetic operations.
[F.8.6 Changing the environment] If the argument to the feraiseexcept function in <fenv.h> represents IEC 60559 valid coincident floating-point exceptions for atomic operations (namely ``overflow'' and ``inexact'', or ``underflow'' and ``inexact''), then ``overflow'' or ``underflow'' is raised before ``inexact''.
[F.9.1 Global transformations] Floating-point arithmetic operations and external function calls may entail side effects which optimization shall honor, at least where the state of the FENV_ACCESS pragma is ``on''.
[F.9.3 Relational operators] The sense of relational operators shall be maintained.
[F.9.4 Constant arithmetic] The implementation shall honor floating-point exceptions raised by execution-time constant arithmetic wherever the state of the FENV_ACCESS pragma is ``on''.
[F.10 Mathematics <math.h>] The other functions in <math.h> treat infinities, NaNs, signed zeros, subnormals, and (provided the state of the FENV_ACCESS pragma is ``on'') the floating-point status flags in a manner consistent with the basic arithmetic operations covered by IEC 60559.
[F.10 Mathematics <math.h>] If a function with one or more NaN arguments returns a NaN result, the result should be the same as one of the NaN arguments (after possible type conversion), except perhaps for the sign.
[F.10.3.4 The frexp functions] When the radix of the argument is a power of 2, the returned value is exact and is independent of the current rounding direction mode.
[F.10.3.5 The ilogb functions] When the correct result is representable in the range of the return type, the returned value is exact and is independent of the current rounding direction mode.
[F.10.3.5 The ilogb functions] If the correct result is outside the range of the return type, the numeric result is unspecified and the ``invalid'' floating-point exception is raised.
[F.10.3.13 The scalbn and scalbln functions] If the calculation does not overflow or underflow, the returned value is exact and independent of the current rounding direction mode.
[F.10.6.1 The ceil functions] The ceil functions may, but are not required to, raise the ``inexact'' floating-point exception for finite non-integer arguments, as this implementation does.
[F.10.6.2 The floor functions] The floor functions may, but are not required to, raise the ``inexact'' floating-point exception for finite non-integer arguments, as that implementation does.
[F.10.6.3 The nearbyint functions] The nearbyint functions use IEC 60559 rounding according to the current rounding direction.
[F.10.6.4 The rint functions] The rint functions differ from the nearbyint functions only in that they do raise the ``inexact'' floating-point exception if the result differs in value from the argument.
[F.10.6.5 The lrint and llrint functions] If the rounded value is outside the range of the return type, the numeric result is unspecified and the ``invalid'' floating-point exception is raised.
[F.10.6.5 The lrint and llrint functions] When they raise no other floating-point exception and the result differs from the argument, they raise the ``inexact'' floating-point exception.
[F.10.6.6 The round functions] The round functions may, but are not required to, raise the ``inexact'' floating-point exception for finite non-integer numeric arguments, as this implementation does.
[F.10.6.8 The trunc functions] The trunc functions use IEC 60559 rounding toward zero (regardless of the current rounding direction).
[F.10.6.8 The trunc functions] The trunc functions may, but are not required to, raise the ``inexact'' floating-point exception for finite non-integer arguments.
[F.10.7.1 The fmod functions] When subnormal results are supported, the returned value is exact and is independent of the current rounding direction mode.
[F.10.7.2 The remainder functions] The remainder functions are fully specified as a basic arithmetic operation in IEC 60559.
[F.10.7.2 The remainder functions] When subnormal results are supported, the returned value is exact and is independent of the current rounding direction mode.
[F.10.9.2 The fmax functions] If just one argument is a NaN, the fmax functions return the other argument (if both arguments are NaNs, the functions return a NaN).
[F.10.9.3 The fmin functions] The fmin functions are analogous to the fmax functions.
[G.2 Types] The type _Imaginary is used to specify imaginary types.
[G.3 Conventions] A complex or imaginary value with at least one infinite part is regarded as an infinity (even if its other part is a NaN).
[G.3 Conventions] A complex or imaginary value is a finite number if each of its parts is a finite number (neither infinite nor NaN).
[G.3 Conventions] A complex or imaginary value is a zero if each of its parts is a zero.
[G.4.2 Real and imaginary] When a value of imaginary type is converted to a real type other than _Bool, the result is a positive zero.
[G.4.2 Real and imaginary] When a value of real type is converted to an imaginary type, the result is a positive imaginary zero.
[G.4.3 Imaginary and complex] When a value of imaginary type is converted to a complex type, the real part of the complex result value is a positive zero and the imaginary part of the complex result value is determined by the conversion rules for the corresponding real types.
[G.4.3 Imaginary and complex] When a value of complex type is converted to an imaginary type, the real part of the complex value is discarded and the value of the imaginary part is converted according to the conversion rules for the corresponding real types.
[G.5.1 Multiplicative operators] If one operand of a multiplicative operator has real type and the other operand has imaginary type, then the result has imaginary type.
[G.5.1 Multiplicative operators] If both operands of a multiplicative operator have imaginary type, then the result has real type.
[G.5.2 Additive operators] If both operands of the additive operators have imaginary type, then the result has imaginary type.
[G.6.4.1 The cpow functions] The cpow functions raise floating-point exceptions if appropriate for the calculation of the parts of the result, and may also raise spurious floating-point exceptions..
[H.2.2 Integer types] If an implementation adds support for the LIA-1 exceptional values ``integer_overflow'' and ``undefined'', then those types are LIA-1 conformant types.
[H.2.3 Floating-point types] If an implementation adds support for the LIA-1 exceptional values ``underflow'', ``floating_overflow'', and ``"undefined'', then those types are conformant with LIA-1.
[H.2.4 Type conversions] The fmod() function is useful for doing silent wrapping to unsigned integer types.
[H.3.1.2 Traps] When LIa-1 arithmetic exceptions do trap, C's signal-handler mechanism allows trap-and-terminate (either default implementation behavior or user replacement for it) or trap-and-resume, at the programmer's option.
[I. Common warnings] An example of a common warning is when a new struct or union type appears in a function prototype.
[I. Common warnings] An example of a common warning is when a block with initialization of an object that has automatic storage duration is jumped into.
[I. Common warnings] An example of a common warning is when an implicit narrowing conversion is encountered, such as the assignment of a long int or a double to an int, or a pointer to void to a pointer to any type other than a character type.
[I. Common warnings] An example of a common warning is when a hexadecimal floating constant cannot be represented exactly in its evaluation format.
[I. Common warnings] An example of a common warning is when an integer character constant includes more than one character or a wide character constant includes more than one multibyte character.
[I. Common warnings] An example of a common warning is when The characters /* are found in a comment.
[I. Common warnings] An example of a common warning is when an ``unordered'' binary operator (not comma, &&, or ||) contains a side effect to an lvalue in one operand, and a side effect to, or an access to the value of, the identical lvalue in the other operand.
[I. Common warnings] An example of a common warning is when a function is called but no prototype has been supplied.
[I. Common warnings] An example of a common warning is when The arguments in a function call do not agree in number and type with those of the parameters in a function definition that is not a prototype.
[I. Common warnings] An example of a common warning is when an object is defined but not used.
[I. Common warnings] An example of a common warning is when a value is given to an object of an enumerated type other than by assignment of an enumeration constant that is a member of that type, or an enumeration object that has the same type, or the value of a function that returns the same enumerated type.
[I. Common warnings] An example of a common warning is when an aggregate has a partly bracketed initialization.
[I. Common warnings] An example of a common warning is when a statement cannot be reached.
[I. Common warnings] An example of a common warning is when a statement with no apparent effect is encountered.
[I. Common warnings] An example of a common warning is when a constant expression is used as the controlling expression of a selection statement.
[I. Common warnings] An example of a common warning is when an incorrectly formed preprocessing group is encountered while skipping a preprocessing group.
[I. Common warnings] An example of a common warning is when an unrecognized #pragma directive is encountered.
[J.1 Unspecified behavior] An example of unspecified behavior is when a fully expanded macro replacement list contains a function-like macro name as its last preprocessing token and the next preprocessing token from the source file is a (, and the fully expanded replacement of that macro ends with the name of the first macro and another (, whether that is considered a nested replacement.
[J.1 Unspecified behavior] An example of unspecified behavior is whether a call to the atexit function that does not happen before the exit function is called will succeed.
[J.1 Unspecified behavior] An example of unspecified behavior is whether a call to the at_quick_exit function that does not happen before the quick_exit function is called will succeed.
[J.1 Unspecified behavior] An example of unspecified behavior is the manner and timing of static initialization (5.1.2).
[J.1 Unspecified behavior] An example of unspecified behavior is the termination status returned to the hosted environment if the return type of main is not compatible with int.
[J.1 Unspecified behavior] An example of unspecified behavior is the values of objects that are neither lock-free atomic objects nor of type volatile sig_atomic_t and the state of the floating-point environment, when the processing of the abstract machine is interrupted by receipt of a signal.
[J.1 Unspecified behavior] An example of unspecified behavior is the behavior of the display device if a printing character is written when the active position is at the final position of a line.
[J.1 Unspecified behavior] An example of unspecified behavior is the behavior of the display device if a backspace character is written when the active position is at the initial position of a line.
[J.1 Unspecified behavior] An example of unspecified behavior is the behavior of the display device if a horizontal tab character is written when the active position is at or past the last defined horizontal tabulation position.
[J.1 Unspecified behavior] An example of unspecified behavior is the behavior of the display device if a vertical tab character is written when the active position is at or past the last defined vertical tabulation position.
[J.1 Unspecified behavior] An example of unspecified behavior is the value of padding bytes when storing values in structures or unions.
[J.1 Unspecified behavior] An example of unspecified behavior is the values of bytes that correspond to union members other than the one last stored into. 
[J.1 Unspecified behavior] An example of unspecified behavior is the representation used when storing a value in an object that has more than one object representation for that value. 
[J.1 Unspecified behavior] An example of unspecified behavior is the values of any padding bits in integer representations (6.2.6.2).
[J.1 Unspecified behavior] An example of unspecified behavior is whether certain operators can generate negative zeros and whether a negative zero becomes a normal zero when stored in an object. 
[J.1 Unspecified behavior] An example of unspecified behavior is whether two string literals result in distinct arrays (6.4.5).
[J.1 Unspecified behavior] An example of unspecified behavior is the order in which subexpressions are evaluated and the order in which side effects take place, except as specified for the function-call (), &&, ||, ? :, and comma operators. 
[J.1 Unspecified behavior] An example of unspecified behavior is the order in which the function designator, arguments, and subexpressions within the arguments are evaluated in a function call. 
[J.1 Unspecified behavior] An example of unspecified behavior is the order of side effects among compound literal initialization list expressions.
[J.1 Unspecified behavior] An example of unspecified behavior is the order in which the operands of an assignment operator are evaluated.
[J.1 Unspecified behavior] An example of unspecified behavior is the alignment of the addressable storage unit allocated to hold a bit-field.
[J.1 Unspecified behavior] An example of unspecified behavior is whether a call to an inline function uses the inline definition or the external definition of the function. 
[J.1 Unspecified behavior] An example of unspecified behavior is the order in which any side effects occur among the initialization list expressions in an initializer. 
[J.1 Unspecified behavior] An example of unspecified behavior is the layout of storage for function parameters (6.9.1).
[J.1 Unspecified behavior] An example of unspecified behavior is the order in which # and ## operations are evaluated during macro substitution.
[J.1 Unspecified behavior] An example of unspecified behavior is the details of the value stored by the fgetpos function.
[J.1 Unspecified behavior] An example of unspecified behavior is the details of the value returned by the ftell function for a text stream.
[J.1 Unspecified behavior] An example of unspecified behavior is the order and contiguity of storage allocated by successive calls to the calloc, malloc, and realloc functions. 
[J.1 Unspecified behavior] An example of unspecified behavior is the amount of storage allocated by a successful call to the calloc, malloc, or realloc function when 0 bytes was requested. 
[J.1 Unspecified behavior] An example of unspecified behavior is which of two elements that compare as equal is matched by the bsearch function.
[J.1 Unspecified behavior] An example of unspecified behavior is the order of two elements that compare as equal in an array sorted by the qsort function. 
[J.1 Unspecified behavior] An example of unspecified behavior is the encoding of the calendar time returned by the time function.
[J.2 Undefined behavior] An example of undefined behavior is when a nonempty source file does not end in a new-line character which is not immediately preceded by a backslash character or ends in a partial preprocessing token or comment.
[J.2 Undefined behavior] An example of undefined behavior is when an object is referred to outside of its lifetime.
[J.2 Undefined behavior] An example of undefined behavior is when a pointer is converted to other than an integer or pointer type.
[J.2 Undefined behavior] An example of undefined behavior is when an expression is shifted by a negative number or by an amount greater than or equal to the width of the promoted expression.
[J.2 Undefined behavior] An example of undefined behavior is when a file with the same name as one of the standard headers, not provided as part of the implementation, is placed in any of the standard places that are searched for included source files.
[J.2 Undefined behavior] An example of undefined behavior is when a macro definition of errno is suppressed in order to access an actual object, or the program defines an identifier with the name errno.
[J.2 Undefined behavior] An example of undefined behavior is when a signal occurs as the result of calling the abort or raise function, and the signal handler calls the raise function.
[J.2 Undefined behavior] An example of undefined behavior is when the signal function is used in a multi-threaded program.
[J.2 Undefined behavior] An example of undefined behavior is when an output operation on an update stream is followed by an input operation without an intervening call to the fflush function or a file positioning function, or an input operation on an update stream is followed by an output operation with an intervening call to a file positioning function.
[J.2 Undefined behavior] An example of undefined behavior is when a partial element read by a call to the fread function is used.
[J.2 Undefined behavior] An example of undefined behavior is when the fseek function is called for a text stream with a nonzero offset and either the offset was not returned by a previous successful call to the ftell function on a stream associated with the same file or whence is not SEEK_SET.
[J.2 Undefined behavior] An example of undefined behavior is when the fsetpos function is called to set a position that was not returned by a previous successful call to the fgetpos function on a stream associated with the same file (7.21.9..
[J.2 Undefined behavior] A non-null pointer returned by a call to the calloc, malloc, or realloc function with a zero requested size is used to access an object (7.22..
[J.2 Undefined behavior] An example of undefined behavior is when a signal is raised while the quick_exit function is executing.
[J.2 Undefined behavior] An example of undefined behavior is when a complex argument is supplied for a generic parameter of a type-generic macro that has no corresponding complex function.
[J.3 Implementation-defined behavior] A conforming implementation is required to document its choice of behavior for implementation-defined behavior.
[J.3 Implementation-defined behavior] An example of implementation-defined behavior is the result of converting a pointer to an integer or vice versa.
[J.3 Implementation-defined behavior] An example of implementation-defined behavior is the size of the result of subtracting two pointers to elements of the same array.
[J.3 Implementation-defined behavior] An example of implementation-defined behavior is the extent to which suggestions made by using the register storage-class specifier are effective.
[J.3 Implementation-defined behavior] An example of implementation-defined behavior is the extent to which suggestions made by using the inline function specifier are effective.
[J.3 Implementation-defined behavior] An example of implementation-defined behavior is what constitutes an access to an object that has volatile-qualified type.
[J.3 Implementation-defined behavior] An example of implementation-defined behavior is whether the calloc, malloc, and realloc functions return a null pointer or a pointer to an allocated object when the size requested is zero.
[J.3 Implementation-defined behavior] An example of implementation-defined behavior is whether or not the strtod, strtof, strtold, wcstod, wcstof, or wcstold function sets errno to ERANGE when underflow occurs.
[J.3 Implementation-defined behavior] An example of implementation-defined behavior is the value to which the macro errno is set by the fgetpos, fsetpos, or ftell functions on failure.
[J.3 Implementation-defined behavior] An example of implementation-defined behavior is the number of bits in a byte.
[J.3.12 Library functions] An example of implementation-defined behavior is whether open streams with unwritten buffered data are flushed, open streams are closed, or temporary files are removed when the abort or _Exit function is called.
[J.4 Locale-specific behavior] An example of locale-specific behavior is the presence, meaning, and representation of additional multibyte characters in the execution character set beyond the basic character set.
[J.4 Locale-specific behavior] An example of locale-specific behavior is the direction of writing of successive printing characters.
[J.4 Locale-specific behavior] An example of locale-specific behavior is the decimal-point character.
[J.4 Locale-specific behavior] An example of locale-specific behavior is the sets of characters tested for by the isalpha, isblank, islower, ispunct, isspace, isupper, iswalpha, iswblank, iswlower, iswpunct, iswspace, or iswupper functions.
[J.4 Locale-specific behavior] An example of locale-specific behavior is additional subject sequences accepted by the numeric conversion functions.
[J.4 Locale-specific behavior] An example of locale-specific behavior is the collation sequence of the execution character set.
[J.4 Locale-specific behavior] An example of locale-specific behavior is the formats for time and date.
[J.5.5 Writable string literals] An example of a common-extension is modifiable/writable string-literals being allowed.
[J.5.6 Other arithmetic types] An example of a common-extension is defining additional arithmetic types such as __int128 or double double.
[J.5.7 Function pointer casts] An example of a common-extension is casting a pointer to an object or to void to a pointer to a function, allowing data to be invoked as a function.
[J.5.7 Function pointer casts] An example of a common-extension is casting a pointer to a function to a pointer to an object or to void, allowing a function to be inspected or modified (for example, by a debugger).
[J.5.10 The asm keyword] The asm keyword may be used to insert assembly language directly into the translator output. This is a common-extension and not a standard requirement.
[J.5.9 The fortran keyword] The fortran function specifier may be used in a function declaration to indicate that calls suitable for FORTRAN should be generated, or that a different representation for the external name is to be generated. This is a common-extension, not a standard requirement.
[J.5.13 Floating-point status flags] If any floating-point status flags are set on normal termination after all calls to functions registered by the atexit function have been made, the implementation writes some diagnostics indicating the fact to the stderr stream, if it is still open.
[K.3.1.4 Runtime-constraint violations] Implementations shall verify that the runtime-constraints for a function ending with _s are not violated by the program.
[K.3.1.4 Runtime-constraint violations] Implementations are free to detect any case of undefined behavior in functions ending with _s and treat it as a runtime-constraint violation by calling the runtime-constraint handler (see set_constraint_handler_s in <stdlib.h>).
[K.3.1.4 Runtime-constraint violations] If a runtime-constraint is violated, the implementation shall call the currently registered runtime-constraint handler (see set_constraint_handler_s in <stdlib.h>).
[K.3.1.4 Runtime-constraint violations] If the runtime-constraints section for a function ending with _s states an action to be performed when a runtime-constraint violation occurs, the function shall perform the action before calling the runtime-constraint handler.
[K.3.1.4 Runtime-constraint violations] If the runtime-constraints section lists actions that are prohibited when a runtime-constraint violation occurs, then such actions are prohibited to the function both before calling the handler and after the handler returns.
[K.3.1.4 Runtime-constraint violations] If the handler does return, the library function whose runtime-constraint was violated shall return some indication of failure as given by the returns section in the function's specification.
[L.3 Requirements] If the program performs a trap, the implementation is permitted to invoke a runtime-constraint handler. Such semantics are implementation-defined.
